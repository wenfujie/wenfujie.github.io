<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温富杰 blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wenf.top/"/>
  <updated>2021-03-24T08:15:33.731Z</updated>
  <id>http://wenf.top/</id>
  
  <author>
    <name>温富杰</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack热更新原理</title>
    <link href="http://wenf.top/2021/03/24/webpack%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://wenf.top/2021/03/24/webpack热更新原理/</id>
    <published>2021-03-24T07:34:01.000Z</published>
    <updated>2021-03-24T08:15:33.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Hot Module Replacement，简称HMR，无需完全刷新整个页面的同时，更新模块。HMR的好处，在日常开发工作中体会颇深：节省宝贵的开发时间、提升开发体验。</p></blockquote><p>通常我们可以通过 <code>HotModuleReplacementPlugin</code> 或 启动指令增加参数 <code>--hot</code> 来启用热更新。</p><p>如果不关心细节只想知道热更新的大概流程，请直接拉到文章末尾 <code>总结</code> 。</p><p><strong>HMR是如何实现热更新的呢？下面一步步拆分介绍</strong></p><h2 id="热更新实现原理"><a href="#热更新实现原理" class="headerlink" title="热更新实现原理"></a>热更新实现原理</h2><h3 id="1-webpack-dev-server启动本地服务"><a href="#1-webpack-dev-server启动本地服务" class="headerlink" title="1. webpack-dev-server启动本地服务"></a>1. webpack-dev-server启动本地服务</h3><p>我们根据<code>webpack-dev-server</code>的<code>package.json</code>中的<code>bin</code>命令，可以找到命令的入口文件<code>bin/webpack-dev-server.js</code>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules/webpack-dev-server/bin/webpack-dev-server.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成webpack编译主引擎 compiler</span></span><br><span class="line"><span class="keyword">let</span> compiler = webpack(config);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动本地服务</span></span><br><span class="line"><span class="keyword">let</span> server = <span class="keyword">new</span> Server(compiler, options, log);</span><br><span class="line">server.listen(options.port, options.host, (err) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;<span class="keyword">throw</span> err&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p>本地服务代码：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules/webpack-dev-server/lib/Server.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.setupApp();</span><br><span class="line">        <span class="keyword">this</span>.createServer();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    setupApp() &#123;</span><br><span class="line">        <span class="comment">// 依赖了express</span></span><br><span class="line">    <span class="keyword">this</span>.app = <span class="keyword">new</span> express();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    createServer() &#123;</span><br><span class="line">        <span class="keyword">this</span>.listeningApp = http.createServer(<span class="keyword">this</span>.app);</span><br><span class="line">    &#125;</span><br><span class="line">    listen(port, hostname, fn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.listeningApp.listen(port, hostname, (err) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 启动express服务后，启动websocket服务</span></span><br><span class="line">            <span class="keyword">this</span>.createSocketServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;                                   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><p>这一小节代码主要做了三件事：</p><ul><li>启动<code>webpack</code>，生成<code>compiler</code>实例。<code>compiler</code>上有很多方法，比如可以启动 <code>webpack</code> 所有<strong>编译</strong>工作，以及<strong>监听</strong>本地文件的变化。</li><li>使用<code>express</code>框架启动本地<code>server</code>，让浏览器可以请求本地的<strong>静态资源</strong>。</li><li>本地<code>server</code>启动之后，再去启动<code>websocket</code>服务，如果不了解<code>websocket</code>，建议简单了解一下<a href="https://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">websocket速成</a>。通过<code>websocket</code>，可以建立本地服务和浏览器的双向通信。这样就可以实现当本地文件发生变化，立马告知浏览器可以热更新代码啦！</li></ul><p>上述代码主要干了三件事，但是源码在启动服务前又做了很多事，接下来便看看<code>webpack-dev-server/lib/Server.js</code>还做了哪些事？</p><h3 id="2-修改webpack-config-js的entry配置"><a href="#2-修改webpack-config-js的entry配置" class="headerlink" title="2. 修改webpack.config.js的entry配置"></a>2. 修改webpack.config.js的entry配置</h3><p>启动本地服务前，调用了<code>updateCompiler(this.compiler)</code>方法。这个方法中有 2 段关键性代码。一个是获取<code>websocket</code>客户端代码路径，另一个是根据配置获取<code>webpack</code>热更新代码路径。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取websocket客户端代码</span></span><br><span class="line"><span class="keyword">const</span> clientEntry = <span class="string">`<span class="subst">$&#123;<span class="built_in">require</span>.resolve(</span></span></span><br><span class="line"><span class="string"><span class="subst">    <span class="string">'../../client/'</span></span></span></span><br><span class="line"><span class="string"><span class="subst">)&#125;</span>?<span class="subst">$&#123;domain&#125;</span><span class="subst">$&#123;sockHost&#125;</span><span class="subst">$&#123;sockPath&#125;</span><span class="subst">$&#123;sockPort&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据配置获取热更新代码</span></span><br><span class="line"><span class="keyword">let</span> hotEntry;</span><br><span class="line"><span class="keyword">if</span> (options.hotOnly) &#123;</span><br><span class="line">    hotEntry = <span class="built_in">require</span>.resolve(<span class="string">'webpack/hot/only-dev-server'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.hot) &#123;</span><br><span class="line">    hotEntry = <span class="built_in">require</span>.resolve(<span class="string">'webpack/hot/dev-server'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><p>修改后的<code>webpack</code>入口配置如下：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改后的entry入口</span></span><br><span class="line">&#123; <span class="attr">entry</span>:</span><br><span class="line">    &#123; <span class="attr">index</span>: </span><br><span class="line">        [</span><br><span class="line">            <span class="comment">// 上面获取的clientEntry</span></span><br><span class="line">            <span class="string">'xxx/node_modules/webpack-dev-server/client/index.js?http://localhost:8080'</span>,</span><br><span class="line">            <span class="comment">// 上面获取的hotEntry</span></span><br><span class="line">            <span class="string">'xxx/node_modules/webpack/hot/dev-server.js'</span>,</span><br><span class="line">            <span class="comment">// 开发配置的入口</span></span><br><span class="line">            <span class="string">'./src/index.js'</span></span><br><span class="line">    ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><p>为什么要新增了 2 个文件？在入口默默增加了 2 个文件，那就意味会一同打包到<code>bundle</code>文件中去，也就是线上运行时。</p><p><strong>（1）webpack-dev-server/client/index.js</strong></p><p>首先这个文件用于<code>websocket</code>的，因为<code>websoket</code>是双向通信，如果不了解<code>websocket</code>，建议简单了解一下<a href="https://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">websocket速成</a>。我们在第 1 步 <code>webpack-dev-server</code>初始化 的过程中，启动的是本地服务端的<code>websocket</code>。那客户端也就是我们的浏览器，浏览器还没有和服务端通信的代码呢？总不能让开发者去写吧hhhhhh。因此我们需要把<code>websocket</code>客户端通信代码偷偷塞到我们的代码中。客户端具体的代码后面会在合适的时机细讲哦。</p><p><strong>（2）webpack/hot/dev-server.js</strong></p><p>这个文件主要是用于检查更新逻辑的，这里大家知道就好，代码后面会在合适的时机（<strong>第5步</strong>）细讲。</p><h3 id="3-监听webpack编译结束"><a href="#3-监听webpack编译结束" class="headerlink" title="3. 监听webpack编译结束"></a>3. 监听webpack编译结束</h3><p>修改好入口配置后，又调用了<code>setupHooks</code>方法。这个方法是用来注册监听事件的，监听每次<code>webpack</code>编译完成。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules/webpack-dev-server/lib/Server.js</span></span><br><span class="line"><span class="comment">// 绑定监听事件</span></span><br><span class="line">setupHooks() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;done&#125; = compiler.hooks;</span><br><span class="line">    <span class="comment">// 监听webpack的done钩子，tapable提供的监听方法</span></span><br><span class="line">    done.tap(<span class="string">'webpack-dev-server'</span>, (stats) =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>._sendStats(<span class="keyword">this</span>.sockets, <span class="keyword">this</span>.getStats(stats));</span><br><span class="line">        <span class="keyword">this</span>._stats = stats;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p><p>当监听到一次<code>webpack</code>编译结束，就会调用<code>_sendStats</code>方法通过<code>websocket</code>给浏览器发送通知，<code>ok</code>和<code>hash</code>事件，这样浏览器就可以拿到最新的<code>hash</code>值了，做检查更新逻辑。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过websoket给客户端发消息</span></span><br><span class="line">_sendStats() &#123;</span><br><span class="line">    <span class="keyword">this</span>.sockWrite(sockets, <span class="string">'hash'</span>, stats.hash);</span><br><span class="line">    <span class="keyword">this</span>.sockWrite(sockets, <span class="string">'ok'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h3 id="4-webpack监听文件变化"><a href="#4-webpack监听文件变化" class="headerlink" title="4. webpack监听文件变化"></a>4. webpack监听文件变化</h3><p>每次修改代码，就会触发编译。说明我们还需要监听本地代码的变化，主要是通过<code>setupDevMiddleware</code>方法实现的。</p><p>这个方法主要执行了<code>webpack-dev-middleware</code>库。很多人分不清<code>webpack-dev-middleware</code>和<code>webpack-dev-server</code>的区别。其实就是因为<code>webpack-dev-server</code>只负责启动服务和前置准备工作，所有文件相关的操作都抽离到<code>webpack-dev-middleware</code>库了，主要是本地文件的<strong>编译</strong>和<strong>输出</strong>以及<strong>监听</strong>，无非就是职责的划分更清晰了。</p><p>那我们来看下<code>webpack-dev-middleware</code>源码里做了什么事:<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules/webpack-dev-middleware/index.js</span></span><br><span class="line">compiler.watch(options.watchOptions, (err) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123; <span class="comment">/*错误处理*/</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过“memory-fs”库将打包后的文件写入内存</span></span><br><span class="line">setFs(context, compiler);</span><br></pre></td></tr></table></figure></div></p><p>（1）调用了<code>compiler.watch</code>方法，在第 1 步中也提到过，<code>compiler</code>的强大。这个方法主要就做了 2 件事：</p><ul><li>首先对本地文件代码进行编译打包，也就是<code>webpack</code>的一系列编译流程。</li><li>其次编译结束后，开启对本地文件的监听，当文件发生变化，重新编译，编译完成之后继续监听。</li></ul><p>为什么代码的改动保存会自动编译，重新打包？这一系列的重新检测编译就归功于<code>compiler.watch</code>这个方法了。监听本地文件的变化主要是通过<strong>文件的生成时间</strong>是否有变化，这里就不细讲了。</p><p>（2）执行<code>setFs</code>方法，这个方法主要目的就是将编译后的文件打包到内存。这就是为什么在开发的过程中，你会发现<code>dist</code>目录没有打包后的代码，因为都在内存中。原因就在于访问内存中的代码比访问文件系统中的文件更快，而且也减少了代码写入文件的开销，这一切都归功于<code>memory-fs</code>。</p><h3 id="5-浏览器接收到热更新的通知"><a href="#5-浏览器接收到热更新的通知" class="headerlink" title="5. 浏览器接收到热更新的通知"></a>5. 浏览器接收到热更新的通知</h3><p>我们已经可以监听到文件的变化了，当文件发生变化，就触发重新编译。同时还监听了每次编译结束的事件。当监听到一次<code>webpack</code>编译结束，<code>_sendStats</code>方法就通过<code>websoket</code>给浏览器发送通知，检查下是否需要热更新。下面重点讲的就是<code>_sendStats</code>方法中的<code>ok</code>和<code>hash</code>事件都做了什么。</p><p>那浏览器是如何接收到<code>websocket</code>的消息呢？回忆下第 2 步骤增加的入口文件，也就是<code>websocket</code>客户端代码。</p><pre><code>&apos;xxx/node_modules/webpack-dev-server/client/index.js?http://localhost:8080&apos;</code></pre><p>这个文件的代码会被打包到<code>bundle.js</code>中，运行在浏览器中。来看下这个文件的核心代码吧。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack-dev-server/client/index.js</span></span><br><span class="line"><span class="keyword">var</span> socket = <span class="built_in">require</span>(<span class="string">'./socket'</span>);</span><br><span class="line"><span class="keyword">var</span> onSocketMessage = &#123;</span><br><span class="line">    hash: <span class="function"><span class="keyword">function</span> <span class="title">hash</span>(<span class="params">_hash</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 更新currentHash值</span></span><br><span class="line">        status.currentHash = _hash;</span><br><span class="line">    &#125;,</span><br><span class="line">    ok: <span class="function"><span class="keyword">function</span> <span class="title">ok</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        sendMessage(<span class="string">'Ok'</span>);</span><br><span class="line">        <span class="comment">// 进行更新检查等操作</span></span><br><span class="line">        reloadApp(options, status);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 连接服务地址socketUrl，?http://localhost:8080，本地服务地址</span></span><br><span class="line">socket(socketUrl, onSocketMessage);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reloadApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (hot) &#123;</span><br><span class="line">        log.info(<span class="string">'[WDS] App hot update...'</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// hotEmitter其实就是EventEmitter的实例</span></span><br><span class="line">        <span class="keyword">var</span> hotEmitter = <span class="built_in">require</span>(<span class="string">'webpack/hot/emitter'</span>);</span><br><span class="line">        hotEmitter.emit(<span class="string">'webpackHotUpdate'</span>, currentHash);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><p><code>socket</code>方法建立了<code>websocket</code>和服务端的连接，并注册了 2 个监听事件。</p><ul><li><code>hash</code>事件，更新最新一次打包后的<code>hash</code>值。</li><li><code>ok</code>事件，进行热更新检查。</li></ul><p>热更新检查事件是调用<code>reloadApp</code>方法。比较奇怪的是，这个方法又利用<code>node.js</code>的<code>EventEmitter</code>，发出<code>webpackHotUpdate</code>消息。这是为什么？为什么不直接进行检查更新呢？</p><p>个人理解就是为了更好的维护代码，以及职责划分的更明确。<code>websocket</code>仅仅用于客户端（浏览器）和服务端进行通信。而真正做事情的活还是交回给了<code>webpack</code>。</p><p>那<code>webpack</code>怎么做的呢？再来回忆下第 2 步。入口文件还有一个文件没有讲到，就是：</p><pre><code>&apos;xxx/node_modules/webpack/hot/dev-server.js&apos;</code></pre><p>这个文件的代码同样会被打包到<code>bundle.js</code>中，运行在浏览器中。这个文件做了什么就显而易见了吧！先瞄一眼代码：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules/webpack/hot/dev-server.js</span></span><br><span class="line"><span class="keyword">var</span> check = <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">module</span>.hot.check(<span class="literal">true</span>)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">updatedModules</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 容错，直接刷新页面</span></span><br><span class="line">            <span class="keyword">if</span> (!updatedModules) &#123;</span><br><span class="line">                <span class="built_in">window</span>.location.reload();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 热更新结束，打印信息</span></span><br><span class="line">            <span class="keyword">if</span> (upToDate()) &#123;</span><br><span class="line">                log(<span class="string">"info"</span>, <span class="string">"[HMR] App is up to date."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">window</span>.location.reload();</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hotEmitter = <span class="built_in">require</span>(<span class="string">"./emitter"</span>);</span><br><span class="line">hotEmitter.on(<span class="string">"webpackHotUpdate"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">currentHash</span>) </span>&#123;</span><br><span class="line">    lastHash = currentHash;</span><br><span class="line">    check();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></p><p>这里<code>webpack</code>监听到了<code>webpackHotUpdate</code>事件，并获取最新了最新的<code>hash</code>值，然后终于进行检查更新了。检查更新呢调用的是<code>module.hot.check</code>方法。那么问题又来了，<code>module.hot.check</code>又是哪里冒出来了的！答案是<code>HotModuleReplacementPlugin</code>搞得鬼。这里留个疑问，继续往下看。</p><h3 id="6-HotModuleReplacementPlugin"><a href="#6-HotModuleReplacementPlugin" class="headerlink" title="6. HotModuleReplacementPlugin"></a>6. HotModuleReplacementPlugin</h3><p>前面好像一直是<code>webpack-dev-server</code>做的事，那<code>HotModuleReplacementPlugin</code>在热更新过程中又做了什么伟大的事业呢？</p><p>首先你可以对比下，配置热更新和不配置时<code>bundle.js</code>的区别。内存中看不到？直接执行<code>webpack</code>命令就可以看到生成的<code>bundle.js</code>文件啦。不要用<code>webpack-dev-server</code>启动就好了。</p><p>（1）没有配置的。</p><p><a href="https://user-gold-cdn.xitu.io/2019/12/1/16ec0c9e8fd12349?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-fancybox="group" data-caption class="fancybox"><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ec0c9e8fd12349?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt title></a></p><p>（2）配置了<code>HotModuleReplacementPlugin</code>或<code>--hot</code>的。</p><p><a href="https://user-gold-cdn.xitu.io/2019/12/1/16ec0c90092fa0ac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-fancybox="group" data-caption class="fancybox"><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ec0c90092fa0ac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt title></a></p><p>哦~ 我们发现<code>moudle</code>新增了一个属性为<code>hot</code>，再看<code>hotCreateModule</code>方法。 这不就找到<code>module.hot.check</code>是哪里冒出来的。</p><p><a href="https://user-gold-cdn.xitu.io/2019/12/1/16ec0dc36018973f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-fancybox="group" data-caption class="fancybox"><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ec0dc36018973f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt title></a></p><p>经过对比打包后的文件，<code>__webpack_require__</code>中的<code>moudle</code>以及代码行数的不同。我们都可以发现<code>HotModuleReplacementPlugin</code>原来也是默默的塞了很多代码到<code>bundle.js</code>中呀。这和第 2 步骤很是相似哦！为什么，因为检查更新是在浏览器中操作呀。这些代码必须在运行时的环境。</p><p>你也可以直接看浏览器<code>Sources</code>下的代码，会发现<code>webpack</code>和<code>plugin</code>偷偷加的代码都在哦。在这里调试也很方便。</p><p><code>HotModuleReplacementPlugin</code>如何做到的？这里我就不讲了，因为这需要你对<code>tapable</code>以及<code>plugin</code>机制有一定了解，可以看下我写的文章<a href="https://juejin.im/post/6844904004435050503" target="_blank" rel="noopener">Webpack插件机制之Tapable-源码解析</a>。当然你也可以选择跳过，只关心热更新机制即可，毕竟信息量太大。</p><h3 id="7-moudle-hot-check-开始热更新"><a href="#7-moudle-hot-check-开始热更新" class="headerlink" title="7. moudle.hot.check 开始热更新"></a>7. moudle.hot.check 开始热更新</h3><p>通过第 6 步，我们就可以知道<code>moudle.hot.check</code>方法是如何来的啦。那都做了什么？之后的源码都是<code>HotModuleReplacementPlugin</code>塞入到<code>bundle.js</code>中的哦，我就不写文件路径了。</p><ul><li>利用上一次保存的<code>hash</code>值，调用<code>hotDownloadManifest</code>发送<code>xxx/hash.hot-update.json</code>的<code>ajax</code>请求；</li><li><p>请求结果获取热更新模块，以及下次热更新的<code>Hash</code> 标识，并进入热更新准备阶段。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hotAvailableFilesMap = update.c; <span class="comment">// 需要更新的文件</span></span><br><span class="line">hotUpdateNewHash = update.h; <span class="comment">// 更新下次热更新hash值</span></span><br><span class="line">hotSetStatus(<span class="string">"prepare"</span>); <span class="comment">// 进入热更新准备状态</span></span><br></pre></td></tr></table></figure></div></li><li><p>调用<code>hotDownloadUpdateChunk</code>发送<code>xxx/hash.hot-update.js</code> 请求，通过<code>JSONP</code>方式。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hotDownloadUpdateChunk</span>(<span class="params">chunkId</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">    script.charset = <span class="string">"utf-8"</span>;</span><br><span class="line">    script.src = __webpack_require__.p + <span class="string">""</span> + chunkId + <span class="string">"."</span> + hotCurrentHash + <span class="string">".hot-update.js"</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span>) script.crossOrigin = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div></li></ul><p>这个函数体为什么要单独拿出来，因为这里要解释下为什么使用<code>JSONP</code>获取最新代码？主要是因为<code>JSONP</code>获取的代码可以直接执行。为什么要直接执行？我们来回忆下<code>/hash.hot-update.js</code>的代码格式是怎么样的。</p><p>新编译后的代码是在一个<code>webpackHotUpdate</code>函数体内部的。也就是要立即执行<code>webpackHotUpdate</code>这个方法。</p><p>再看下<code>webpackHotUpdate</code>这个方法。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>[<span class="string">"webpackHotUpdate"</span>] = <span class="function"><span class="keyword">function</span> (<span class="params">chunkId, moreModules</span>) </span>&#123;</span><br><span class="line">    hotAddUpdateChunk(chunkId, moreModules);</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure></div></p><ul><li><code>hotAddUpdateChunk</code>方法会把更新的模块<code>moreModules</code>赋值给全局全量<code>hotUpdate</code>。</li><li><code>hotUpdateDownloaded</code>方法会调用<code>hotApply</code>进行代码的替换。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hotAddUpdateChunk</span>(<span class="params">chunkId, moreModules</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 更新的模块moreModules赋值给全局全量hotUpdate</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> moduleId <span class="keyword">in</span> moreModules) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class="line">    hotUpdate[moduleId] = moreModules[moduleId];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用hotApply进行模块的替换</span></span><br><span class="line">    hotUpdateDownloaded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="8-hotApply-热更新模块替换"><a href="#8-hotApply-热更新模块替换" class="headerlink" title="8. hotApply 热更新模块替换"></a>8. hotApply 热更新模块替换</h3><p>热更新的核心逻辑就在<code>hotApply</code>方法了。 <code>hotApply</code>代码有将近 400 行，还是挑重点讲了</p><h4 id="①删除过期的模块，就是需要替换的模块"><a href="#①删除过期的模块，就是需要替换的模块" class="headerlink" title="①删除过期的模块，就是需要替换的模块"></a>①删除过期的模块，就是需要替换的模块</h4><p>通过<code>hotUpdate</code>可以找到旧模块<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queue = outdatedModules.slice();</span><br><span class="line"><span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    moduleId = queue.pop();</span><br><span class="line">    <span class="comment">// 从缓存中删除过期的模块</span></span><br><span class="line">    <span class="built_in">module</span> = installedModules[moduleId];</span><br><span class="line">    <span class="comment">// 删除过期的依赖</span></span><br><span class="line">    <span class="keyword">delete</span> outdatedDependencies[moduleId];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储了被删掉的模块id，便于更新代码</span></span><br><span class="line">    outdatedSelfAcceptedModules.push(&#123;</span><br><span class="line">        <span class="built_in">module</span>: moduleId</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h4 id="②将新的模块添加到-modules-中"><a href="#②将新的模块添加到-modules-中" class="headerlink" title="②将新的模块添加到 modules 中"></a>②将新的模块添加到 modules 中</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appliedUpdate[moduleId] = hotUpdate[moduleId];</span><br><span class="line"><span class="keyword">for</span> (moduleId <span class="keyword">in</span> appliedUpdate) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) &#123;</span><br><span class="line">        modules[moduleId] = appliedUpdate[moduleId];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="③通过-webpack-require-执行相关模块的代码"><a href="#③通过-webpack-require-执行相关模块的代码" class="headerlink" title="③通过__webpack_require__执行相关模块的代码"></a>③通过__webpack_require__执行相关模块的代码</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; outdatedSelfAcceptedModules.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = outdatedSelfAcceptedModules[i];</span><br><span class="line">    moduleId = item.module;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行最新的代码</span></span><br><span class="line">        __webpack_require__(moduleId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">// ...容错处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><code>hotApply</code>的确比较复杂，知道大概流程就好了，这一小节，要求你对webpack打包后的文件如何执行的有一些了解，大家可以自去看下。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>webpack热更新原理概述</strong></p><p>分为两大步骤来实现</p><p>第一步：启动一个本地服务运行webpack。</p><p>第二步：增加打包入口配置，打包bundle文件并在浏览器上运行。</p><ol><li>webpack通过compiler.watch方法监听文件改动，并用compiler实例编译相关文件</li><li>webpack同时会监听编译完成的钩子，在回调中通过websocket发送消息到浏览器，通知浏览器更新资源。</li><li>浏览器收到消息后发起请求获取新资源，删除旧的资源，将新资源添加到modules上，最后利用<strong>webpack_require</strong>执行新资源代码</li></ol><p><strong>具体实现步骤</strong></p><ul><li><p>一、使用webpack-dev-server启动本地服务</p><ol><li>启动webpack生成compiler实例，compiler主要用于监听本地文件变化和编译工作</li><li>启动本地服务，让浏览器可访问本地静态资源，主要依赖express库</li><li>启动websocket服务，建立浏览器和本地服务的双向通信</li></ol></li><li><p>二、监听编译结束</p><ol><li>利用<code>compiler.hooks</code>提供的<code>done</code>钩子来监听编译结束</li><li>利用websocket通知浏览器编译结束，并传递新的hash值，浏览器做检查更新逻辑</li></ol></li><li><p>三、使用webpack-dev-middleware库编译、输出、监听本地文件</p><ol><li>调用<code>compiler.watch</code>方法，对本地代码进行编译，结束后开启对本地文件的监听，当文件发生变化，重新编译，编译完成后继续监听</li><li>代码编译后，会使用memory-fs库将编译好的文件存放在内存中，这是因为访问内存中的代码比访问系统文件更快，同时也减少了写入文件的开销</li></ol></li><li><p>四、浏览器接收热更新通知</p><ol><li>webpack会在entry增加入口，打包webpack运行时代码到<code>bundle.js</code>中，该部分代码运行在浏览器</li><li>bundle.js代码就是将HotModuleReplacementPlugin插件的代码塞进去</li><li>浏览器通过bundle.js发送ajax请求，请求需要更新的文件和hash值</li><li>通过HotModuleReplacementPlugin中的hotApply方法实现热更新模块替换。主要流程：删除过期模块、将新的模块添加module中、使用<strong>webpack_require</strong>执行相关模块代码</li></ol></li></ul><p>下面是以阅读源码的形式画的图，①-④的小标记，是文件发生变化的一个流程。</p><p><a href="https://user-gold-cdn.xitu.io/2019/12/1/16ec13499800dfce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-fancybox="group" data-caption class="fancybox"><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ec13499800dfce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt title></a></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>本次是以阅读源码的方式讲解原理，是因为觉得热更新这块涉及的知识量比较多。所以知识把关键性代码拿出来，因为每一个块细节说起来都能写一篇文章了，大家可以自己对着源码再理解下。</p><p>还是建议提前了解以下知识会更好理解热更新：</p><ul><li><strong>websocket</strong>：<a href="https://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">websocket基础知识了解</a></li><li>打包后的<code>bundle</code>文件如何运行的。</li><li><code>webpack</code>启动流程，<code>webpack</code>生命周期。</li><li><strong>tapable</strong>: <a href="https://juejin.im/post/6844904004435050503" target="_blank" rel="noopener">Webpack插件机制之Tapable-源码解析</a></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/Jocs/jocs.github.io/issues/15" target="_blank" rel="noopener">Webpack Hot Module Replacement 的原理解析</a></li><li><a href="https://juejin.im/post/6844903953092591630" target="_blank" rel="noopener">看完这篇，面试再也不怕被问 Webpack 热更新</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Hot Module Replacement，简称HMR，无需完全刷新整个页面的同时，更新模块。HMR的好处，在日
      
    
    </summary>
    
      <category term="技术" scheme="http://wenf.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="webpack" scheme="http://wenf.top/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>http协议</title>
    <link href="http://wenf.top/2021/03/22/http%E5%8D%8F%E8%AE%AE/"/>
    <id>http://wenf.top/2021/03/22/http协议/</id>
    <published>2021-03-22T03:54:14.000Z</published>
    <updated>2021-03-24T08:18:35.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一面要讲的内容：</p><ul><li><p>HTTP协议的主要特点</p></li><li><p>HTTP报文的组成部分</p></li><li><p>HTTP方法</p></li><li><p>get 和 post的区别</p></li><li><p>HTTP状态码</p></li><li><p>什么是持久连接</p></li><li><p>什么是管线化</p></li></ul><p>二面要讲的内容；</p><ul><li><p>缓存</p></li><li><p>CSRF攻击</p></li></ul><h2 id="HTTP协议的主要特点"><a href="#HTTP协议的主要特点" class="headerlink" title="HTTP协议的主要特点"></a>HTTP协议的主要特点</h2><ul><li><p>简单快速</p></li><li><p>灵活</p></li><li><p><strong>无连接</strong></p></li><li><p><strong>无状态</strong></p></li></ul><p>通常我们要答出以上四个内容。如果实在记不住，一定要记得后面的两个： <strong>无连接、无状态</strong> 。</p><p>我们分别来解释一下。</p><h3 id="简单快速"><a href="#简单快速" class="headerlink" title="简单快速"></a>简单快速</h3><p><strong>简单</strong> ：每个资源（比如图片、页面）都通过 url 来定位。这都是固定的，在http协议中，处理起来也比较简单，想访问什么资源，直接输入url即可。</p><h3 id="灵活"><a href="#灵活" class="headerlink" title="灵活"></a>灵活</h3><p>http协议的头部有一个<code>数据类型</code>，通过http协议，就可以完成不同数据类型的传输。</p><h3 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h3><p>连接一次，就会断开，不会继续保持连接。</p><h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>客户端和服务器端是两种身份。第一次请求结束后，就断开了，第二次请求时， <strong>服务器端并没有记住之前的状态</strong><br>，也就是说，服务器端无法区分客户端是否为同一个人、同一个身份。</p><p>有的时候，我们访问网站时，网站能记住我们的账号，这个是通过其他的手段（比如 session）做到的，并不是http协议能做到的。</p><h2 id="HTTP报文的组成部分"><a href="#HTTP报文的组成部分" class="headerlink" title="HTTP报文的组成部分"></a>HTTP报文的组成部分</h2><p><a href="https://camo.githubusercontent.com/3776b3dd209ee8fb439e9cc7a718e1d96a9961b1d9249ddd2807e6776b3ba72d/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303330365f313430302e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/3776b3dd209ee8fb439e9cc7a718e1d96a9961b1d9249ddd2807e6776b3ba72d/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303330365f313430302e706e67" alt></a></p><p>在回答此问题时，我们要按照顺序回答：</p><ul><li><p>先回答的是，http报文包括： <strong>请求报文</strong> 和 <strong>响应报文</strong> 。</p></li><li><p>再回答的是，每个报文包含什么部分。</p></li><li><p>最后回答，每个部分的内容是什么</p></li></ul><h3 id="请求报文包括："><a href="#请求报文包括：" class="headerlink" title="请求报文包括："></a>请求报文包括：</h3><p><a href="https://camo.githubusercontent.com/3cdd2cfe28502eb329d61b00f68bf4be6d1d7b93ce55c85b02563cc1ed846efa/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303232385f313530352e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/3cdd2cfe28502eb329d61b00f68bf4be6d1d7b93ce55c85b02563cc1ed846efa/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303232385f313530352e6a7067" alt></a></p><ul><li><p>请求行：包括请求方法、请求的url、http协议及版本。</p></li><li><p>请求头：一大堆的键值对。</p></li><li><p><strong>空行</strong> 指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体。</p></li><li><p>请求体：数据部分。</p></li></ul><h3 id="响应报文包括："><a href="#响应报文包括：" class="headerlink" title="响应报文包括："></a>响应报文包括：</h3><p><a href="https://camo.githubusercontent.com/5a06f9e21a22759fff5cbd19d73e11cd0e6e79ddf927bb5da379039b7d346f47/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303232385f313531302e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/5a06f9e21a22759fff5cbd19d73e11cd0e6e79ddf927bb5da379039b7d346f47/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303232385f313531302e6a7067" alt></a></p><ul><li><p>状态行：http协议及版本、状态码及状态描述。</p></li><li><p>响应头</p></li><li><p>空行</p></li><li><p>响应体</p></li></ul><h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><p>包括：</p><ul><li><p>GET：获取资源</p></li><li><p>POST：传输资源</p></li><li><p>put：更新资源</p></li><li><p>DELETE：删除资源</p></li><li><p>HEAD：获得报文首部</p></li></ul><p>HTTP方法有很多，但是上面这五个方法，要求在面试时全部说出来，不要漏掉。</p><p>get 和 post 比较常见。</p><p>put 和 delete 在实际应用中用的很少。况且，业务中，一般不删除服务器端的资源。</p><p>head 可能偶尔用的到。</p><h2 id="get-和-post的区别"><a href="#get-和-post的区别" class="headerlink" title="get 和 post的区别"></a>get 和 post的区别</h2><p><a href="https://camo.githubusercontent.com/eb94fc7050d60f1ba087c92805b0b4f5ba3b331fb790e5b5fc3b926f7216e28e/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303330365f313431352e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/eb94fc7050d60f1ba087c92805b0b4f5ba3b331fb790e5b5fc3b926f7216e28e/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303330365f313431352e706e67" alt></a></p><p>区别有很多，如果记不住，面试时，至少要任意答出其中的三四条。</p><p>有一点要强调， <strong>get是相对不隐私的，而post是相对隐私的</strong> 。</p><p>我们大概要记住以下几点：</p><p>1、浏览器在回退时，get <strong>不会重新请求</strong> ，但是post会重新请求。【重要】</p><p>2、get请求会被浏览器 <strong>主动缓存</strong> ，而post不会。【重要】</p><p>3、get请求的参数，会 <strong>保留</strong> 在浏览器的 <strong>历史记录</strong><br>里，而post不会。做业务时要注意。为了防止CSRF攻击，很多公司把get统一改成了post。</p><p>4、get请求在url中传递的参数有大小限制，基本是2kb，不同的浏览器略有不同。而post没有限制。</p><p>5、get的参数是直接暴露在url上的，相对不安全。而post是放在请求体中的。</p><h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><p>http状态码分类：</p><p><a href="https://camo.githubusercontent.com/f6cb65a6c2747251a830bc7a74cf514bbef7f05e7434f41145ea9b790aadc595/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303330365f313433302e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/f6cb65a6c2747251a830bc7a74cf514bbef7f05e7434f41145ea9b790aadc595/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303330365f313433302e706e67" alt></a></p><p>部分解释：</p><ul><li>200 OK，表示从客户端发来的请求在服务器端被正常处理了。</li><li>204 No content ，表示请求处理成功，但没有资源返回。</li><li>301 moved permanently，表示永久性重定向。表示请求的资源被分配了新的URI，以后应使用资源现在所指的URI。</li><li>302 found，表示临时性重定向。</li><li>304 表示客户端发送附带条件的请求时（指采用GET方法的请求报文中包含if-matched,if-modified-since,if-none-match,if-range,if-unmodified-since任一个首部）服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304Modified（服务器端资源未改变，可直接使用客户端未过期的缓存）</li><li>400 bad request，表示请求报文中存在语法错误。</li><li>401 unauthorized，表示未授权</li><li>403 forbidden，表示对请求资源的访问被服务器拒绝了</li><li>404 not found，表示服务器上无法找到请求的资源。</li><li>500 internal sever error，表示服务器端在执行请求时发生了错误。</li><li>501 Not Implemented，服务器不支持当前请求所需要的某个功能</li><li>503 service unavailable，表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul><h2 id="持久链接-http长连接"><a href="#持久链接-http长连接" class="headerlink" title="持久链接/http长连接"></a>持久链接/http长连接</h2><blockquote><p>如果你能答出持久链接，这是面试官很想知道的一个点。</p></blockquote><ul><li><p><strong>轮询</strong> ：http1.0中，客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。</p></li><li><p><strong>长连接</strong> ：HTTP1.1中，通过使用Connection:keep-alive进行长连接，。客户端只请求一次，但是服务器会将继续保持连接，当再次请求时，避免了重新建立连接。</p></li></ul><p>注意，HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对 <strong>每个请求仍然要单独发 header</strong> ，Keep-<br>Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</p><h2 id="长连接中的管线化"><a href="#长连接中的管线化" class="headerlink" title="长连接中的管线化"></a>长连接中的管线化</h2><blockquote><p>如果能答出 <strong>管线化</strong> ，则属于加分项。</p></blockquote><h3 id="管线化的原理"><a href="#管线化的原理" class="headerlink" title="管线化的原理"></a>管线化的原理</h3><p>长连接时， <strong>默认</strong> 的请求这样的：</p><pre><code>请求1 --&gt; 响应1 --&gt;请求2 --&gt; 响应2 --&gt; 请求3 --&gt; 响应3</code></pre><p>长连接中的管线化，请求是这样的：</p><pre><code>请求1 --&gt; 请求2 --&gt; 请求3 --&gt; 响应1 --&gt; 响应2 --&gt; 响应3</code></pre><p>管线化就是，我把现在的请求打包，一次性发过去，你也给我一次响应回来。</p><h3 id="管线化的注意事项"><a href="#管线化的注意事项" class="headerlink" title="管线化的注意事项"></a>管线化的注意事项</h3><p>面试时，不会深究管线化。如果真要问你，就回答：“我没怎么研究过，准备回去看看~”</p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>中文名：传输控制协议（Transmission Control Protocol）。是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><p>http 和 TCP 的关系？</p><p>http协议是位于应用层，用来定义 request 和 response 的规则，而 TCP 位于传输层，用来传输客户端、服务端的 request、response。</p><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p><strong>含义</strong></p><p>由于TCP是面向连接的，所以客户端和服务端发送数据前要先建立一条连接在TCP/IP协议中，连接建立成功后再开始正式传输数据，TCP三次握手就是用于建立该连接。</p><p><strong>步骤</strong></p><ol><li><p>第一次握手: 客户端发送请求，询问是否同意建立连接</p></li><li><p>第二次握手: 服务器收到信息, 并请求与客户端建立连接</p></li><li><p>第三次握手: 客户端收到信息系, 同意与服务器建立连接</p></li></ol><p><strong>作用</strong></p><p>一、二次握手是为了保证服务端能接收客户端信息并作出应答，二、三次握手是为了保证客户端能接受到服务端信息并做应答。</p><h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p><strong>含义</strong></p><p>当数据传输完毕，就需要断开TCP连接，TCP四次挥手就是用于断开TCP连接。</p><p><strong>步骤</strong></p><ol><li><p>第一次分手: 客户端发送断开请求</p></li><li><p>第二次分手: 服务器收到断开请求, 发送同意断开连接的请求</p></li><li><p>第三次分手: 服务器发送请求断开连接</p></li><li><p>第四次分手: 客户端收到, 发送同意断开连接</p></li></ol><h2 id="HTTPS的原理和作用"><a href="#HTTPS的原理和作用" class="headerlink" title="HTTPS的原理和作用"></a>HTTPS的原理和作用</h2><p>HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。</p><p>要讲清楚https，需要知道以下几个知识点</p><ol><li>对称加密与非对称加密的概念</li><li>SSL/TLS 协议的含义</li><li>CA 证书的用途</li></ol><p><strong>对称加密与非对称加密</strong></p><p>秘钥：一种算法</p><p>加密：通过秘钥将明文变成密文的过程</p><p>解密：通过秘钥将密文变成明文的过程</p><p>对称加密：对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密</p><p>非对称加密：有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道</p><p><strong>SSL/TLS 协议</strong></p><p><strong>作用</strong>：http 协议是明文的，存在传输内容会被偷窥和篡改等问题，SSL协议就是为了解决这些问题。</p><p>1999年，SSL被标准化，标准化后改名为 TLS（Transport Layer Security），中文叫“传输层安全协议”。所以 SSL 和 TLS 指的是同一个东西。</p><p><strong>TLS 握手过程</strong></p><p><a href="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043749.jpg" data-fancybox="group" data-caption class="fancybox"><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043749.jpg" alt title></a></p><ol><li>客户端发送一个随机值，需要的协议和加密方式</li><li>服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）</li><li>客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书</li><li>服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密</li></ol><p>通过以上步骤可知，在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。</p><h2 id="http1和http2的区别"><a href="#http1和http2的区别" class="headerlink" title="http1和http2的区别"></a>http1和http2的区别</h2><p>http1存在队头阻塞问题（同一个域名下限制最大请求数）。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">传输方式</th><th style="text-align:center">多路复用</th><th style="text-align:center">header压缩</th><th style="text-align:center">服务器推送</th></tr></thead><tbody><tr><td style="text-align:center">http1</td><td style="text-align:center">文本</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">http2</td><td style="text-align:center">二进制</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr></tbody></table><p><strong>辅助记忆</strong></p><p>推广二多头：推广表示服务器推送，二多头为”二锅头谐音”</p><p><strong>原文：</strong></p><p><a href="https://github.com/qianguyihao/Web/blob/master/13-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/01-%E9%9D%A2%E8%AF%95%E5%BF%85%E7%9C%8B/04-HTTP%E5%8D%8F%E8%AE%AE.md" target="_blank" rel="noopener">https://github.com/qianguyihao/Web/blob/master/13-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/01-%E9%9D%A2%E8%AF%95%E5%BF%85%E7%9C%8B/04-HTTP%E5%8D%8F%E8%AE%AE.md</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;一面要讲的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;HTTP协议的主要特点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HTTP报文的组成部分&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术" scheme="http://wenf.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="网络" scheme="http://wenf.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>闭包,我吃定鉨了耶稣都挡不住,我说的</title>
    <link href="http://wenf.top/2021/03/02/%E9%97%AD%E5%8C%85-%E6%88%91%E5%90%83%E5%AE%9A%E9%89%A8%E4%BA%86%E8%80%B6%E7%A8%A3%E9%83%BD%E6%8C%A1%E4%B8%8D%E4%BD%8F-%E6%88%91%E8%AF%B4%E7%9A%84/"/>
    <id>http://wenf.top/2021/03/02/闭包-我吃定鉨了耶稣都挡不住-我说的/</id>
    <published>2021-03-02T07:38:49.000Z</published>
    <updated>2021-03-24T08:06:34.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>在面试中被面试官问及什么是闭包？大概率你会如下回答：</p><blockquote><p>在A函数中返回B函数，B函数使用到了A函数中的局部变量，这就是闭包。</p></blockquote><p>这段描述是ok的，为了下次被问到能回答得更炫，一起来从更专业的角度认识闭包。</p><p>先来看一个例子：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">'lily'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">insider</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> insider;</span><br><span class="line">&#125;;</span><br><span class="line">outer()(); <span class="comment">// my name is lily</span></span><br></pre></td></tr></table></figure></div><p>例子中，哪一部分是闭包？</p><p><strong>这段代码中的闭包指代的就是内部函数 insider，而非外部函数outer所包含的范围</strong>，这一点要清楚。<br>闭包其实就是一个自带了执行环境（由外层函数提供，即便外层函数销毁依旧可以访问）的特殊函数。</p><h2 id="闭包的特征"><a href="#闭包的特征" class="headerlink" title="闭包的特征"></a>闭包的特征</h2><p>看下其他文献对闭包的解释：</p><p>百度百科：</p><blockquote><p>闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。</p></blockquote><p>《JavaScript高级编程指南》：</p><blockquote><p>闭包是指有权访问另外一个函数作用域中的变量的函数。</p></blockquote><p>站在技术实践角度来说，闭包无非满足以下两点：</p><ul><li><strong>闭包首先得是一个函数。</strong></li><li><strong>闭包能访问外部函数作用域中的变量，即使外部函数上下文已销毁。</strong></li></ul><p>那闭包的核心特征是什么呢？</p><ul><li>自带执行环境</li><li>外部函数的变量在内存持久化，直到闭包函数被销毁</li></ul><p>举个板栗：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">1</span>; <span class="comment">//自由变量</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        a: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(num);</span><br><span class="line">        &#125;,</span><br><span class="line">        b: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> closure = fn();</span><br><span class="line"><span class="comment">//到这里外部函数已执行完毕，执行上下文被释放</span></span><br><span class="line">closure.a(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></div><p>在上方的例子中，外层函数fn执行返回了两个闭包 a，b。我们知道函数每次被调用执行都会创建一个新的执行上下文，当函数执行完毕函数执行上下文被弹出执行栈并销毁，所以在 let closure = fn() 执行完毕时函数fn的执行上下文已不复存在，但我们执行closure.a()可以看到依旧能访问到外层函数的局部变量num。</p><p>为了让这种感觉更为强烈，我们直接销毁掉函数fn再次调用闭包函数，可以看到闭包不仅是访问甚至还能操作外层函数中的变量。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn = <span class="literal">null</span>;</span><br><span class="line">closure.b();</span><br><span class="line">closure.a(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div><h2 id="闭包的使用场景"><a href="#闭包的使用场景" class="headerlink" title="闭包的使用场景"></a>闭包的使用场景</h2><h3 id="1-模拟私有属性"><a href="#1-模拟私有属性" class="headerlink" title="1.模拟私有属性"></a>1.模拟私有属性</h3><p><strong>私有属性</strong>：只能被同一个类中其他方法调用的属性或方法。</p><p>javascript中不提供专门创建私有属性的方法，但我们可以通过闭包来模拟创建类的私有方法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用闭包模拟私有属性</span></span><br><span class="line"><span class="keyword">let</span> count = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        num += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            handle(<span class="number">2</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        decrement: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            handle(<span class="number">-1</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        getNum: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">count.add();</span><br><span class="line">count.decrement();</span><br><span class="line"><span class="built_in">console</span>.log(count.getNum()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></div><p>以上例子模拟创建了私有属性num、handle。这两个属性仅限被返回的对象中的add、decrement、<br>getNum三个闭包方法使用。</p><h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2.构造函数"></a>2.构造函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 构造函数中使用闭包 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Woman</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 私有变量</span></span><br><span class="line">    <span class="keyword">let</span> sex = <span class="string">'female'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`you can call me <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, my sex is <span class="subst">$&#123;sex&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> lily = <span class="keyword">new</span> Woman(<span class="string">'lily'</span>);</span><br><span class="line">lily.sayHello(); <span class="comment">// 'you can call me lily, my sex is female'</span></span><br></pre></td></tr></table></figure></div><p>以上例子中 <strong>new Woman</strong> 后，会返回一个包含 name 属性以及 sayHello 闭包方法的对象。该类型的构造函数也会使用到闭包功能。</p><h3 id="3-函数柯里化"><a href="#3-函数柯里化" class="headerlink" title="3.函数柯里化"></a>3.函数柯里化</h3><blockquote><p>维基百科上说道：柯里化，英语：Currying(果然是满满的英译中的既视感)，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 函数柯里化 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curringAdd</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(curringAdd(<span class="number">1</span>)(<span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div><p>以上例子中，我们利用了闭包自带执行环境的特性（即使外层作用域已销毁），仅仅使用一个形参完成了两个形参求和的操作。</p><h3 id="4-Angular的过滤器"><a href="#4-Angular的过滤器" class="headerlink" title="4.Angular的过滤器"></a>4.Angular的过滤器</h3><p>闭包在很多框架中都有应用，比如angularjs中可以自定义过滤器</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'myApp'</span>,[])</span><br><span class="line">.filter(<span class="string">'filterName'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><h3 id="5-实现设计模式的单例模式"><a href="#5-实现设计模式的单例模式" class="headerlink" title="5.实现设计模式的单例模式"></a>5.实现设计模式的单例模式</h3><p>一句话介绍单例模式：<strong>保证类只有一个实例，并提供一个全局的访问点。</strong></p><p>实现单例模式的逻辑很简单，判断目标类是否已创建实例，如果已创建则直接返回，如果未创建则创建一个实例并返回。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'触发了构造函数'</span>);</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  sayHello() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`hello,my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 代理实现单例模式</span></span><br><span class="line"><span class="keyword">let</span> proxyMode = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Person(name);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> personA = <span class="keyword">new</span> proxyMode(<span class="string">'personA'</span>); <span class="comment">// 打印“触发了构造函数”</span></span><br><span class="line"><span class="keyword">let</span> personB = <span class="keyword">new</span> proxyMode(<span class="string">'personB'</span>); <span class="comment">// 无打印</span></span><br><span class="line"></span><br><span class="line">personA.sayHello(); <span class="comment">// hello,my name is personA</span></span><br><span class="line">personB.sayHello(); <span class="comment">// hello,my name is personA</span></span><br></pre></td></tr></table></figure></div><p>上面例子核心代码在 proxyMode 代理中，主要利用闭包将已创建的目标类 Person 的实例存放到 instance 中，只要 proxyMode 创建的实例不销毁，instance 就一直存放在内存中。</p><p>当我们多次使用 proxyMode 去创建实例时，例如例子中 personA 和 personB，返回的实例都是首次创建的实例，所以两个实例执行 sayHello 方法打印内容都是“hello,my name is personA”</p><h2 id="使用闭包的注意事项"><a href="#使用闭包的注意事项" class="headerlink" title="使用闭包的注意事项"></a>使用闭包的注意事项</h2><p><strong>1.闭包的性能和内存占用</strong></p><p>由于闭包自带执行环境，外层函数的变量无法释放，所以内存的占用比普通函数大。</p><p>使用闭包时，可以手动去释放无需使用到的变量，以减少内存的占用。</p><p>例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ele = <span class="built_in">document</span>.querySelector(<span class="string">'.ele'</span>);</span><br><span class="line">    <span class="keyword">let</span> color = ele.style.color;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 闭包仅使用到 color </span></span><br><span class="line">    ele.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(color);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动释放ele变量</span></span><br><span class="line">    ele = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">bindEvent();</span><br></pre></td></tr></table></figure></div><p><strong>2.闭包中this指向</strong></p><p>先做个题，下面例子打印什么？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"lily"</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"sam"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.sayName()(); <span class="comment">// ？</span></span><br></pre></td></tr></table></figure></div><p>如果对 this 的理解不够深入，就可能会答错。<strong>正确输出是 lily</strong>。首先我们要知道 this 的作用域跟静态作用域相反，它是在调用函数时才确定的，指向调用该函数的对象。</p><p>所以上面代码最后一行可以理解为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done = obj.sayName()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处是 window 调用闭包函数，故打印值为 window.name</span></span><br><span class="line"><span class="built_in">window</span>.done();</span><br></pre></td></tr></table></figure></div><p>如果要在闭包中访问外层函数的 this 怎么办？你可能猜到了，很简单，将外层 this 保存到内存中：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"lily"</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"sam"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(_this.name);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.sayName()(); <span class="comment">// sam</span></span><br></pre></td></tr></table></figure></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们了解到：</p><ol><li>闭包其实就是自带了执行环境的函数，被它使用了的外部函数变量会一直存在内存中，直到闭包函数被销毁；</li><li>使用闭包的场景：模拟私有属性、构造器、函数柯里化、Angular 中的 filter 过滤器、实现单例模式</li><li>在使用闭包时我们要把注意内存的占用，把不需要用到的变量手动释放；</li><li>使用闭包时要注意闭包函数中 this 的作用域；</li></ol><p>如果在以后的面试中有面试官问你闭包，我希望你能通过在这里学到的知识秀的对方头皮发麻。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是闭包&quot;&gt;&lt;a href=&quot;#什么是闭包&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包&quot;&gt;&lt;/a&gt;什么是闭包&lt;/h2&gt;&lt;p&gt;在面试中被面试官问及什么是闭包？大概率你会如下回答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在A函数中返回B函数，
      
    
    </summary>
    
      <category term="技术" scheme="http://wenf.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="js" scheme="http://wenf.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>npm使用及发布包</title>
    <link href="http://wenf.top/2021/02/03/npm%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8F%91%E5%B8%83%E5%8C%85/"/>
    <id>http://wenf.top/2021/02/03/npm使用及发布包/</id>
    <published>2021-02-03T07:43:40.000Z</published>
    <updated>2021-03-24T08:15:29.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id="npm-常用指令"><a href="#npm-常用指令" class="headerlink" title="npm 常用指令"></a>npm 常用指令</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化package.json文件（自定义内容）</span></span><br><span class="line">npm init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化package.json文件（默认内容）</span></span><br><span class="line">npm init -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装package.json上所有的包</span></span><br><span class="line">npm install  或 npm i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定包到开发环境</span></span><br><span class="line">npm i vue --save-dev 或 npm i vue -D</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装制定包到生产环境</span></span><br><span class="line">npm i vue --save 或 npm i vue -S</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局安装</span></span><br><span class="line">npm install webpack -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看非全局安装的包（--depth表示依赖深度，是否显示包的相关依赖）</span></span><br><span class="line">npm list --depth 0 或 npm ls --depth 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有的全局包</span></span><br><span class="line">npm list -g --depth 0 或 npm ls -g --depth 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看包的版本</span></span><br><span class="line">npm view packName versions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新指定包</span></span><br><span class="line">npm update @wenfujie/sonicmoving-deploy-frontend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载包</span></span><br><span class="line">npm uninstall vue</span><br></pre></td></tr></table></figure></div><p><strong>npm 账号相关</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注册 npm 账号(根据 提示输入用户名、密码、邮箱，等待账号创建完成)</span></span><br><span class="line">npm adduser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录npm</span></span><br><span class="line">npm login</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前账号</span></span><br><span class="line">npm whoami</span><br></pre></td></tr></table></figure></div></p><h2 id="发布-npm-包"><a href="#发布-npm-包" class="headerlink" title="发布 npm 包"></a>发布 npm 包</h2><p><strong>初始化 package.json</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若未登录，需先登录npm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化package.json文件，--scope表示包的范围（免费的仅支持使用登录人名称）</span></span><br><span class="line">npm init --scope=wenfujie</span><br></pre></td></tr></table></figure></div></p><p>以下包的配置信息最好详细填写，会在 npm 官网中展示，便于让用户找到代码仓库和了解相关信息。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">json</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"@wenfujie/cli"</span>, <span class="comment">// 包名</span></span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>, <span class="comment">// 版本编号</span></span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"个人cli工具"</span>, <span class="comment">// 描述</span></span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>, <span class="comment">// 包执行的入口</span></span><br><span class="line">  <span class="attr">"repository"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"git"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">""</span> <span class="comment">// 代码仓库地址</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [ <span class="comment">// 关键词</span></span><br><span class="line">    <span class="string">"deploy"</span> </span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"bin"</span>: &#123;</span><br><span class="line">    <span class="comment">// 全局安装时的全局指令，值为要执行的文件路径</span></span><br><span class="line">    <span class="attr">"wfj-cli"</span>: <span class="string">"./index.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"fujie.wen"</span> <span class="comment">// 作者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><p><strong>发布</strong></p><p>发布前，修改版本号</p><p>如果是一个新的包，他的版本号必须从 1.0.0 开始，尽管npm上的有些项目并没有遵循该标准。在此之后，版本更新应遵循一下原则： </p><ul><li>bug修复和其他小的改动：补丁发布，增加最后一个数字，例如 1.0.1</li><li>增加新特性，不打破现有特性：小版本，增加中间的数字，如 1.1.0</li><li>打破向后兼容性的变化：主要版本，增加第一个数字，例如 2.0.0</li></ul><p>执行以下发布指令，即可发布成功<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数 access=public 表示发布公有包</span></span><br><span class="line"><span class="comment"># 不加 access 参数发布私有包，私有包需付费</span></span><br><span class="line"><span class="comment"># 每次发版版本号需递增（具体看下文《公共包语义化版本号》</span></span><br><span class="line">npm publish --access=public</span><br></pre></td></tr></table></figure></div></p><p><strong>撤销发布</strong></p><p>官方对撤销发布有所限制：</p><ul><li>不允许撤销发布已经超过24小时的包（unpublish is only allowed with versions published in the last 24 hours）</li><li>如果在24小时内确实要撤销，需要加–force参数</li><li>即使撤销了发布的包，再次发布的版本号不能与之前被撤销的包的名称/版本其中之一相同，因为这两者构成的唯一性已经被占用，官方并没有随着撤销而删除<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm unpublish packName --force</span><br></pre></td></tr></table></figure></div></li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="替换-npm-源为淘宝源"><a href="#替换-npm-源为淘宝源" class="headerlink" title="替换 npm 源为淘宝源"></a>替换 npm 源为淘宝源</h3><p>在国内下载部分国外的包，速度较慢，此时修改 npm 源来提升下载速度<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前源</span></span><br><span class="line">npm get registry <span class="comment"># https://registry.npmjs.org/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用淘宝源代替 npm 源</span></span><br><span class="line">npm config <span class="built_in">set</span> registry http://registry.npm.taobao.org/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换回 npm 默认源</span></span><br><span class="line">npm config <span class="built_in">set</span> registry=http://registry.npmjs.org</span><br></pre></td></tr></table></figure></div></p><h3 id="解决-electron-包下载慢"><a href="#解决-electron-包下载慢" class="headerlink" title="解决 electron 包下载慢"></a>解决 electron 包下载慢</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先安装cross=-env</span></span><br><span class="line">npm i cross-env -D</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用淘宝源下载 electron</span></span><br><span class="line">cross-env ELECTRON_MIRROR=<span class="string">"https://cdn.npm.taobao.org/dist/electron/"</span> npm install electron --save-dev</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;npm-常用指令&quot;&gt;&lt;a href=&quot;#npm-常用指令&quot; class=&quot;headerlink&quot; title=&quot;npm 常用指令&quot;&gt;&lt;/a&gt;npm 常用指令&lt;/h2&gt;&lt;div class=&quot;code-area-wrap&quot;&gt;&lt;div class=&quot;highlight
      
    
    </summary>
    
      <category term="技术" scheme="http://wenf.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="工具" scheme="http://wenf.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Cors解决跨域请求</title>
    <link href="http://wenf.top/2021/01/04/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Cors%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/"/>
    <id>http://wenf.top/2021/01/04/如何使用Cors解决跨域请求/</id>
    <published>2021-01-04T07:48:27.000Z</published>
    <updated>2021-03-24T08:10:01.107Z</updated>
    
    <content type="html"><![CDATA[<p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</p><p>它允许浏览器向跨源服务器，发出<a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="noopener"><code>XMLHttpRequest</code></a>请求，从而克服了AJAX只能<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">同源</a>使用的限制。</p><p>本文详细介绍CORS的内部机制。</p><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p><p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p><p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p><h2 id="二、两种请求"><a href="#二、两种请求" class="headerlink" title="二、两种请求"></a>二、两种请求</h2><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p><p>只要同时满足以下两大条件，就属于简单请求。</p><blockquote><p>（1) 请求方法是以下三种方法之一：</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul></blockquote><blockquote><p>（2）HTTP的头信息不超出以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul></blockquote><p>这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。</p><p>凡是不同时满足上面两个条件，就属于非简单请求。</p><p>浏览器对这两种请求的处理，是不一样的。</p><h2 id="三、简单请求"><a href="#三、简单请求" class="headerlink" title="三、简单请求"></a>三、简单请求</h2><h3 id="3-1-基本流程"><a href="#3-1-基本流程" class="headerlink" title="3.1 基本流程"></a>3.1 基本流程</h3><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p><p>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p><blockquote><pre><code>GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...</code></pre></blockquote><p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p><p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><blockquote><pre><code>Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8</code></pre></blockquote><p>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头。</p><p><strong>（1）Access-Control-Allow-Origin</strong></p><p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p><p><strong>（2）Access-Control-Allow-Credentials</strong></p><p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p><p><strong>（3）Access-Control-Expose-Headers</strong></p><p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p><h3 id="3-2-withCredentials-属性"><a href="#3-2-withCredentials-属性" class="headerlink" title="3.2 withCredentials 属性"></a>3.2 withCredentials 属性</h3><p>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p><blockquote><pre><code>Access-Control-Allow-Credentials: true</code></pre></blockquote><p>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。</p><blockquote><pre><code>var xhr = new XMLHttpRequest();xhr.withCredentials = true;</code></pre></blockquote><p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p><p>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭<code>withCredentials</code>。</p><blockquote><pre><code>xhr.withCredentials = false;</code></pre></blockquote><p>需要注意的是，如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</p><h2 id="四、非简单请求"><a href="#四、非简单请求" class="headerlink" title="四、非简单请求"></a>四、非简单请求</h2><h3 id="4-1-预检请求"><a href="#4-1-预检请求" class="headerlink" title="4.1 预检请求"></a>4.1 预检请求</h3><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p><p>下面是一段浏览器的JavaScript脚本。</p><blockquote><pre><code>var url = &apos;http://api.alice.com/cors&apos;;var xhr = new XMLHttpRequest();xhr.open(&apos;PUT&apos;, url, true);xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);xhr.send();</code></pre></blockquote><p>上面代码中，HTTP请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p><p>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。</p><blockquote><pre><code>OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...</code></pre></blockquote><p>“预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p><p>除了<code>Origin</code>字段，”预检”请求的头信息包括两个特殊字段。</p><p><strong>（1）Access-Control-Request-Method</strong></p><p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<code>PUT</code>。</p><p><strong>（2）Access-Control-Request-Headers</strong></p><p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</p><h3 id="4-2-预检请求的回应"><a href="#4-2-预检请求的回应" class="headerlink" title="4.2 预检请求的回应"></a>4.2 预检请求的回应</h3><p>服务器收到”预检”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p><blockquote><pre><code>HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain</code></pre></blockquote><p>上面的HTTP回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p><blockquote><pre><code>Access-Control-Allow-Origin: *</code></pre></blockquote><p>如果服务器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息。</p><blockquote><pre><code>XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</code></pre></blockquote><p>服务器回应的其他CORS相关字段如下。</p><blockquote><pre><code>Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000</code></pre></blockquote><p><strong>（1）Access-Control-Allow-Methods</strong></p><p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p><p><strong>（2）Access-Control-Allow-Headers</strong></p><p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p><p><strong>（3）Access-Control-Allow-Credentials</strong></p><p>该字段与简单请求时的含义相同。</p><p><strong>（4）Access-Control-Max-Age</strong></p><p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p><h3 id="4-3-浏览器的正常请求和回应"><a href="#4-3-浏览器的正常请求和回应" class="headerlink" title="4.3 浏览器的正常请求和回应"></a>4.3 浏览器的正常请求和回应</h3><p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p><p>下面是”预检”请求之后，浏览器的正常CORS请求。</p><blockquote><pre><code>PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...</code></pre></blockquote><p>上面头信息的<code>Origin</code>字段是浏览器自动添加的。</p><p>下面是服务器正常的回应。</p><blockquote><pre><code>Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8</code></pre></blockquote><p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的。</p><h2 id="五、与JSONP的比较"><a href="#五、与JSONP的比较" class="headerlink" title="五、与JSONP的比较"></a>五、与JSONP的比较</h2><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p><p>JSONP只支持<code>GET</code>请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这边只针对复杂请求来说</p><p><strong>浏览器的处理</strong></p><p>发送请求跨域时，浏览器会先发送一个预请求，并在请求头中加入以下信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">oxygene</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /cors HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line">Access-Control-Request-<span class="function"><span class="keyword">Method</span>:</span> PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure></div><p>预请求用的请求方法是 OPTIONS ，表示该请求用来询问。其中里头有三个比较关键的字段：</p><ol><li>Origin：表示请求来自哪个源</li><li>Access-Control-Request-Method：该字段是必须得，用来列出在浏览器cors请求中允许使用的方法</li><li>Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器cors请求会额外发送的头信息字段</li></ol><p><strong>服务器的处理</strong><br>服务器收到预请求后，检查Origin、Access-Control-Request-Method和Access-Control- Request-Headers字段，确认是否允许跨源请求。</p><p><strong>如果允许跨域</strong></p><p>服务器会在预请求的响应头中添加Access-Control-Allow-Origin来表示允许跨域的源</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">groovy</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * 表示所有源都支持跨域</span></span><br><span class="line">Access-Control-Allow-<span class="string">Origin:</span> *</span><br><span class="line"><span class="comment">// 或指定特定源</span></span><br><span class="line">Access-Control-Allow-<span class="string">Origin:</span> <span class="string">http:</span><span class="comment">//api.bob.com</span></span><br></pre></td></tr></table></figure></div><p>服务器通过预请求后，之后浏览器就能正常发起cors请求。</p><p>服务器响应预请求的其他cors字段</p><ol><li>Access-Control-Allow-Methods：逗号分隔字符串，表示服务器支持跨域的请求方法</li><li>Access-Control-Allow-Headers：逗号分隔字符串，表示服务器支持的所有头字段信息</li><li>Access-Control-Allow-Credentials：允许客户端发送cookie</li><li>Access-Control-Max-Age：可选字段，指定本次预请求有效期</li></ol><p><strong>如果拒绝跨域</strong></p><p>服务器拒绝跨域请求，会返回一个正常的http响应，但头部中没有任何cors相关字段信息。浏览器接收到后会认定预请求已被拒绝，然后触发一个错误</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot <span class="keyword">load</span> <span class="keyword">http</span>://api.alice.com.</span><br><span class="line">Origin <span class="keyword">http</span>://api.bob.com <span class="keyword">is</span> <span class="keyword">not</span> allowed <span class="keyword">by</span> <span class="keyword">Access</span>-Control-<span class="keyword">Allow</span>-Origin.</span><br></pre></td></tr></table></figure></div><p><strong>原文：</strong></p><p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。&lt;/p&gt;
&lt;p&gt;它允许浏览器向跨源服务器，发出&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/09/xmlhttpreq
      
    
    </summary>
    
      <category term="技术" scheme="http://wenf.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="跨域" scheme="http://wenf.top/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>性能优化</title>
    <link href="http://wenf.top/2020/11/14/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://wenf.top/2020/11/14/性能优化/</id>
    <published>2020-11-14T07:53:08.000Z</published>
    <updated>2021-03-24T08:12:14.264Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#前言">前言</a></li><li><a href="#一资源压缩合并减少http请求">一、资源压缩合并，减少http请求</a></li><li><a href="#二非核心代码异步加载">二、非核心代码异步加载</a><ul><li><a href="#动态脚本加载">动态脚本加载</a></li><li><a href="#defer">defer</a></li><li><a href="#async">async</a></li><li><a href="#defer和async的区别">defer和async的区别</a></li></ul></li><li><a href="#三利用浏览器缓存">三、利用浏览器缓存</a><ul><li><a href="#强缓存">强缓存</a></li><li><a href="#协商缓存">协商缓存</a></li></ul></li><li><a href="#四使用cdn">四、使用CDN</a></li><li><a href="#五dns预解析dns-prefetch">五、DNS预解析（dns-prefetch）</a></li><li><a href="#总结">总结</a></li><li><a href="#拓展">拓展</a><ul><li><a href="#vue优化">Vue优化</a></li></ul></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>提升页面性能优化的方法有哪些：</p><ul><li><p>1、资源压缩合并，减少http请求</p></li><li><p>2、 <strong>非核心代码异步加载</strong> --&gt; 异步加载的方式 –&gt; 异步加载的区别</p></li></ul><p>如果回答出<code>非核心代码异步加载</code>，就会层层深入。</p><ul><li>3、利用浏览器缓存 –&gt; 缓存的分类 –&gt; 缓存的原理</li></ul><p><strong>缓存</strong> 是所有性能优化的方式中最重要的一步，这个一定要答好。【重要】</p><p>有的人可能会回答local storage 和session storage，其实不是这个。浏览器缓存和存储不是一回事。</p><ul><li>4、使用CDN</li></ul><p>浏览器第一次打开页面时，缓存是起不了作用的。CDN这一条，一定要说出来。</p><ul><li>5、DNS预解析</li></ul><h2 id="一、资源压缩合并，减少http请求"><a href="#一、资源压缩合并，减少http请求" class="headerlink" title="一、资源压缩合并，减少http请求"></a>一、资源压缩合并，减少http请求</h2><ul><li><p>合并图片（css sprites）、CSS和JS文件合并、CSS和JS文件压缩</p></li><li><p>图片较多的页面也可以使用 lazyLoad 等技术进行优化。</p></li><li><p>精灵图等</p></li></ul><h2 id="二、非核心代码异步加载"><a href="#二、非核心代码异步加载" class="headerlink" title="二、非核心代码异步加载"></a>二、非核心代码异步加载</h2><p>异步加载的方式：（这里不说框架，只说原理）</p><ul><li><p>动态脚本加载</p></li><li><p>defer</p></li><li><p>async</p></li></ul><h3 id="动态脚本加载"><a href="#动态脚本加载" class="headerlink" title="动态脚本加载"></a>动态脚本加载</h3><p>使用document.createElement创建一个script标签，即<code>document.createElement(&#39;script&#39;)</code>，然后把这个标签加载到body上面去。</p><p>参考链接：</p><ul><li><a href="https://www.jianshu.com/p/13cf23a90328" target="_blank" rel="noopener">javascript 异步加载</a> 动态脚本加载的那部分代码，看不太懂。</li></ul><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>通过异步的方式加载defer1.js文件：</p><pre><code>&lt;script src=&quot;./defer1.js&quot; defer&gt;&lt;/script&gt;</code></pre><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><blockquote><p>HTmL5新增特性。</p></blockquote><p>通过异步的方式加载async1.js文件：</p><pre><code>&lt;script src=&quot;./async1.js&quot; async&gt;&lt;/script&gt;</code></pre><h3 id="defer和async的区别"><a href="#defer和async的区别" class="headerlink" title="defer和async的区别"></a>defer和async的区别</h3><ul><li><p>defer：在HTML解析完之后才会执行。如果是多个，则按照加载的顺序依次执行。</p></li><li><p>async：在加载完之后立即执行。如果是多个，执行顺序和加载顺序无关。</p></li></ul><p>代码举例：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;!--通过异步的方式引入两个外部的js文件--&gt;    &lt;script src=&quot;./defer1.js&quot; defer&gt;&lt;/script&gt;    &lt;script src=&quot;./defer2.js&quot; defer&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;    console.log(&apos;同步任务&apos;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>上方打印的结果是：</p><pre><code>同步任务defer1defer2</code></pre><p>因为defer的加载是有顺序的，所以两个引入defer文件按顺序执行。如果把引入的文件改为async的方式加载，打印的结果可能是：</p><pre><code>同步任务async2async1</code></pre><p>参考链接：</p><ul><li><a href="https://segmentfault.com/a/1190000006778717" target="_blank" rel="noopener">浅谈script标签的defer和async</a></li></ul><h2 id="三、利用浏览器缓存"><a href="#三、利用浏览器缓存" class="headerlink" title="三、利用浏览器缓存"></a>三、利用浏览器缓存</h2><p><strong>缓存</strong> ：资源文件（比如图片）在 <strong>本地的硬盘</strong> 里存有副本，浏览器下次请求的时候，可能直接从本地磁盘里读取，而不会重新请求图片的url。</p><p>缓存分为：</p><ul><li><p>强缓存</p></li><li><p>协商缓存</p></li></ul><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p><strong>强缓存</strong> ：不用请求服务器，直接使用本地的缓存。</p><p>强缓存是利用 http 响应头中的 <code>Expires</code> 或  <code>Cache-Control</code> 实现的。【重要】</p><p>浏览器第一次请求一个资源时，服务器在返回该资源的同时，会把上面这两个属性放在response header中。比如：</p><p><a href="https://camo.githubusercontent.com/587d427f6c169ea4d24dff9da59251dbc2487c06adb652dccc489dd31903b6c5/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303331305f323331302e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/587d427f6c169ea4d24dff9da59251dbc2487c06adb652dccc489dd31903b6c5/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303331305f323331302e706e67" alt></a></p><p><strong>注意</strong> ：这两个response header属性可以只启用一个，也可以同时启用。当response header中，Expires和Cache-<br>Control同时存在时， <strong>Cache-Control的优先级高于Expires</strong> 。</p><p>下面讲一下二者的区别。</p><p><strong>1、<code>Expires</code></strong>：服务器返回的 <strong>绝对时间</strong> 。</p><p>是较老的强缓存管理 response<br>header。浏览器再次请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires的时间之前，就能命中缓存，否则就不行。</p><p>如果缓存没有命中，浏览器直接从服务器请求资源时，Expires Header在重新请求的时候会被更新。</p><p><strong>缺点：</strong></p><p>由于<code>Expires</code>是服务器返回的一个绝对时间，存在的问题是：服务器的时间和客户端的时间可能不一致。在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改客户端时间，就能影响缓存命中的结果。所以，在http1.1中，提出了一个新的response<br>header，就是Cache-Control。</p><p><strong>2、<code>Cache-Control</code></strong>：服务器返回的 <strong>相对时间</strong> 。</p><p>http1.1中新增的 response<br>header。浏览器第一次请求资源之后，在接下来的相对时间之内，都可以利用本地缓存。超出这个时间之后，则不能命中缓存。重新请求时，<code>Cache-Control</code>会被更新。</p><p><strong>客户端请求时可选值</strong></p><table><thead><tr><th style="text-align:center">可选值</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">max-age=\<seconds></seconds></td><td style="text-align:center">设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间。</td></tr><tr><td style="text-align:center">max-stale[=\<seconds>]</seconds></td><td style="text-align:center">覆盖max-age或者Expires头，但是仅适用于共享缓存(比如各个代理)，私有缓存会忽略它。</td></tr><tr><td style="text-align:center">min-fresh=\<seconds></seconds></td><td style="text-align:center">表示客户端希望获取一个能在指定的秒数内保持其最新状态的响应。</td></tr><tr><td style="text-align:center">no-cache</td><td style="text-align:center">在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证(协商缓存验证)。</td></tr><tr><td style="text-align:center">no-store</td><td style="text-align:center">缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。</td></tr><tr><td style="text-align:center">no-transform</td><td style="text-align:center">不得对资源进行转换或转变。</td></tr><tr><td style="text-align:center">only-if-cached</td><td style="text-align:center">表明客户端只接受已缓存的响应，并且不要向原始服务器检查是否有更新的拷贝。</td></tr></tbody></table><p><strong>服务端响应时可选值</strong></p><table><thead><tr><th style="text-align:center">可选值</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">must-revalidate</td><td style="text-align:center">一旦资源过期（比如已经超过max-age），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。</td></tr><tr><td style="text-align:center">no-cache</td><td style="text-align:center">在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证(协商缓存验证)。</td></tr><tr><td style="text-align:center">no-store</td><td style="text-align:center">缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。</td></tr><tr><td style="text-align:center">no-transform</td><td style="text-align:center">不得对资源进行转换或转变。</td></tr><tr><td style="text-align:center">public</td><td style="text-align:center">表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。</td></tr><tr><td style="text-align:center">proxy-revalidate</td><td style="text-align:center">与must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。</td></tr><tr><td style="text-align:center">max-age=\<seconds></seconds></td><td style="text-align:center">设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。</td></tr><tr><td style="text-align:center">s-maxage=\<seconds></seconds></td><td style="text-align:center">覆盖max-age或者Expires头，但是仅适用于共享缓存(比如各个代理)，私有缓存会忽略它。</td></tr></tbody></table><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p><strong>协商缓存</strong> ：浏览器发现本地有资源的副本，但是不太确定要不要使用，于是去问问服务器。</p><p>当浏览器对某个资源的请求没有命中强缓存（也就是说超出时间了），就会发一个请求到服务器，验证协商缓存是否命中。</p><p>协商缓存是利用的是两对Header：</p><ul><li><p>第一对：<code>Last-Modified</code>、<code>If-Modified-Since</code></p></li><li><p>第二对：<code>ETag</code>、<code>If-None-Match</code></p></li></ul><p>ETag（Entity Tag）：被请求变量的实体值。</p><p><strong>1、<code>Last-Modified</code>、<code>If-Modified-Since</code></strong>。过程如下：</p><p>（1）浏览器第一次请求一个资源，服务器在返回这个资源的同时，会加上<code>Last-Modified</code>这个 response<br>header，这个header表示这该资源在服务器上的最后修改时间：</p><p><a href="https://camo.githubusercontent.com/b288775a5f88cf7889b097eeab8e7f8fccdaf3c4338a022f104744ddc41f396f/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303331315f313731352e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/b288775a5f88cf7889b097eeab8e7f8fccdaf3c4338a022f104744ddc41f396f/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303331315f313731352e706e67" alt></a></p><p>（2）浏览器再次请求这个资源时，会加上<code>If-Modified-Since</code>这个 request<br>header，这个header的值就是上一次返回的<code>Last-Modified</code>的值：</p><p><a href="https://camo.githubusercontent.com/ce44c8cddd15138292f9f16b09c5efee5bca6cf099fe3e506e9d11e0f0d7a72a/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303331315f313731362e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/ce44c8cddd15138292f9f16b09c5efee5bca6cf099fe3e506e9d11e0f0d7a72a/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303331315f313731362e706e67" alt></a></p><p>（3）服务器收到第二次请求时，会比对浏览器传过来的<code>If-Modified-Since</code>和资源在服务器上的最后修改时间<code>Last-Modified</code>，判断资源是否有变化。如果没有变化则返回304 Not Modified，但不返回资源内容（此时，服务器不会返回 Last-<br>Modified 这个 response header）；如果有变化，就正常返回资源内容（继续重复整个流程）。这是服务器返回304时的response<br>header：</p><p><a href="https://camo.githubusercontent.com/ce5d9bf66f2e4c6fdcdf01bc206f07fdd7f1acb4b5b968aa19734dc638bb644e/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303331315f313732302e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/ce5d9bf66f2e4c6fdcdf01bc206f07fdd7f1acb4b5b968aa19734dc638bb644e/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303331315f313732302e706e67" alt></a></p><p>（4）浏览器如果收到304的响应，就会从缓存中加载资源。</p><p><strong>缺点：</strong></p><p><code>Last-Modified</code>、<code>If-Modified-Since</code>一般来说都是非常可靠的，但面临的问题是：</p><ul><li><p><strong>服务器上的资源变化了，但是最后的修改时间却没有变化</strong> 。</p></li><li><p>如果服务器端在一秒内修改文件两次，但产生的<code>Last-Modified</code>却只有一个值。</p></li></ul><p>这一对header就无法解决这种情况。于是，下面这一对header出场了。</p><p><strong>2、<code>ETag</code>、<code>If-None-Match</code></strong>。过程如下：</p><p>（1）浏览器第一次请求一个资源，服务器在返回这个资源的同时，会加上<code>ETag</code>这个 response<br>header，这个header是服务器根据当前请求的资源生成的 <strong>唯一标识</strong><br>。这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间无关，所以也就很好地补充了<code>Last-Modified</code>的不足。如下：</p><p><a href="https://camo.githubusercontent.com/44e04afe980c17bc99bc19fb9384386827460ec5237e85e2b68370d783098c81/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303331315f313733352e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/44e04afe980c17bc99bc19fb9384386827460ec5237e85e2b68370d783098c81/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303331315f313733352e706e67" alt></a></p><p>（2）浏览器再次请求这个资源时，会加上<code>If-None-Match</code>这个 request<br>header，这个header的值就是上一次返回的<code>ETag</code>的值：</p><p><a href="https://camo.githubusercontent.com/adfccefa13669e178aecd79ac2e420670178b3c8ad649e3586c03923e6b0c1b5/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303331315f313733372e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/adfccefa13669e178aecd79ac2e420670178b3c8ad649e3586c03923e6b0c1b5/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303331315f313733372e706e67" alt></a></p><p>3）服务器第二次请求时，会对比浏览器传过来的<code>If-None-Match</code>和服务器重新生成的一个新的<code>ETag</code>，判断资源是否有变化。如果没有变化则返回304 Not<br>Modified，但不返回资源内容（此时，由于ETag重新生成过，response<br>header中还会把这个ETag返回，即使这个ETag并无变化）。如果有变化，就正常返回资源内容（继续重复整个流程）。这是服务器返回304时的response<br>header：</p><p><a href="https://camo.githubusercontent.com/4bf8a2b05cd99868846f020b22345414a5e88c7a06eb23a9cfb92f66b19cb1b6/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303331315f313734302e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/4bf8a2b05cd99868846f020b22345414a5e88c7a06eb23a9cfb92f66b19cb1b6/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303331315f313734302e706e67" alt></a></p><p>（4）浏览器如果收到304的响应，就会从缓存中加载资源。</p><p>提示：如果面试官问你：与浏览器缓存相关的http header有哪些？你能写出来吗？这是一个亮点。</p><p>参考链接：</p><ul><li><a href="https://www.cnblogs.com/lyzg/p/5125934.html" target="_blank" rel="noopener">浏览器缓存知识小结及应用</a>[荐]</li></ul><h2 id="四、使用CDN"><a href="#四、使用CDN" class="headerlink" title="四、使用CDN"></a>四、使用CDN</h2><p>怎么最快地让用户请求资源。一方面是让资源在传输的过程中变小，另外就是CDN。</p><p>要注意，浏览器第一次打开页面的时候，浏览器缓存是起不了作任何用的，使用CDN，效果就很明显。</p><h2 id="五、DNS预解析（dns-prefetch）"><a href="#五、DNS预解析（dns-prefetch）" class="headerlink" title="五、DNS预解析（dns-prefetch）"></a>五、DNS预解析（dns-prefetch）</h2><p>通过 DNS 预解析来告诉浏览器未来我们可能从某个特定的 URL 获取资源，当浏览器真正使用到该域中的某个资源时就可以尽快地完成 DNS 解析。</p><p><strong>第一步</strong> ：打开或关闭DNS预解析</p><p>你可以通过在服务器端发送 X-DNS-Prefetch-Control 报头。或是在文档中使用值为 http-equiv 的meta标签：</p><pre><code>&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</code></pre><p>需要说明的是，在一些高级浏览器中，页面中所有的超链接（<code>&lt;a&gt;</code>标签），默认打开了DNS预解析。但是，如果页面中采用的https协议，很多浏览器是默认关闭了超链接的DNS预解析。如果加了上面这行代码，则表明强制打开浏览器的预解析。（如果你能在面试中把这句话说出来，则一定是你出彩的地方）</p><p><strong>第二步</strong> ：对指定的域名进行DNS预解析</p><p>如果我们将来可能从 smyhvae.com 获取图片或音频资源，那么可以在文档顶部的 标签中加入以下内容：</p><pre><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://www.smyhvae.com/&quot;&gt;</code></pre><p>当我们从该 URL 请求一个资源时，就不再需要等待 DNS 解析的过程。该技术对使用第三方资源特别有用。</p><p>参考链接：</p><ul><li><p><a href="http://bubkoo.com/2015/11/19/prefetching-preloading-prebrowsing/" target="_blank" rel="noopener">前端性能优化 - 资源预加载</a>[荐]</p></li><li><p><a href="https://www.xuanfengge.com/dns-prefetching-analysis.html" target="_blank" rel="noopener">DNS预解析详解</a></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以结合浏览器打开网站的过程来分析。</p><ul><li><p>首先是域名经过dns服务解析得到ip地址。</p><ul><li><p>在html头部加上meta标签，表示强制打开预解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">html</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meta http-equiv="x-dns-prefetch-control" content="on"&gt;</span><br></pre></td></tr></table></figure></div></li><li><p>在头部使用link标签为制定的域名进行预解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">html</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"http://www.smyhvae.com/"</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li></ul></li></ul><ul><li><p>通过ip向服务发起三次握手，之后向服务发送正式http请求</p><ul><li>减少http请求：防抖节流、雪碧图、使用字体图标、图片列表滚动加载、使用浏览器缓存、将多个js或css打包在一个文件</li><li>降低资源大小：使用gzip压缩、代码压缩</li></ul></li><li><p>服务器处理请求，将结果返回给客户端</p></li><li><p>客户端接收数据并解析，根据解析结果渲染dom</p><ul><li>减少dom数量：分页、懒加载、组件拆分然后按需加载、样式组件（待真实操作时才渲染的组件）、避免使用table布局（一个小改动就触发整个table重新渲染）</li><li>减少渲染次数：使用防抖和节流减少函数触发次数、避免使用行内样式、使用切换class名称来更改样式</li><li>减少回流重绘：回流元素脱离文档流、元素display:none后再进行操作、使用translate代替dom.style.top（前者不触发回流）、使用opacity代替visibility（前者不触发重绘）</li></ul></li><li><p>cdn加速</p></li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="Vue优化"><a href="#Vue优化" class="headerlink" title="Vue优化"></a>Vue优化</h3><ol><li>v-if 和 v-show 区分使用</li><li>computed 和 watch 区分使用</li><li>v-for 必须添加key，key不能是index</li><li>避免v-for 和 v-if一起使用</li><li>仅用于展示的数据可使用 Object.freeze 方法冻结对象，避免数据劫持</li><li>组件销毁时，要在 beforeDestroy 钩子注销事件和计时器，比如 addEventListener 添加的事件、setTimeout等</li><li>图片资源懒加载，可以使用插件 vue-lazyload ，<code>&lt;img v-lazy=&#39;/static/img/1.png&#39;&gt;</code>，该插件会将未出现在可视区域的图片做懒加载</li><li>路由懒加载，使用import()</li><li>插件按需引入</li><li>优化无限滚动加载列表，使用 <code>vue-virtual-scroll-list</code> 插件</li><li>服务端渲染或预渲染</li></ol><p><strong>参考</strong></p><p><a href="https://github.com/qianguyihao/Web/blob/master/13-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/01-%E9%9D%A2%E8%AF%95%E5%BF%85%E7%9C%8B/11-%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.md" target="_blank" rel="noopener">https://github.com/qianguyihao/Web/blob/master/13-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/01-%E9%9D%A2%E8%AF%95%E5%BF%85%E7%9C%8B/11-%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.md</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#前言&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#一资源压缩合并减少http请求&quot;&gt;一、资源压缩合并，减少http请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二非核心代码异步加载&quot;&gt;二、非核心代码异步加载&lt;/a&gt;&lt;ul&gt;
&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://wenf.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="优化" scheme="http://wenf.top/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>js异步-事件循环</title>
    <link href="http://wenf.top/2020/10/25/js%E5%BC%82%E6%AD%A5-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>http://wenf.top/2020/10/25/js异步-事件循环/</id>
    <published>2020-10-25T07:51:25.000Z</published>
    <updated>2021-03-24T08:15:13.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>面试常会问，<strong>为什么js是单线程？为什么需要异步？</strong></p><ol><li><p>假设js是多线程，我们让process1删除元素a，同时让process2编辑元素a，下达两个矛盾的命令，浏览器不知该如何执行，所以js是单线程。</p></li><li><p>如果没有异步，代码是自上而下执行，如果上一行解析用时很长，就会造成阻塞，导致用户体验很差；使用异步，也可以做一些延时任务。</p></li></ol><h2 id="任务队列和事件循环-（Event-Loop）"><a href="#任务队列和事件循环-（Event-Loop）" class="headerlink" title="任务队列和事件循环 （Event Loop）"></a>任务队列和事件循环 （Event Loop）</h2><p><strong>js内部是如何实现异步的？</strong></p><p>主要是以 <code>任务队列</code> 和 <code>事件循环</code> 的概念来实现异步。</p><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>广义上划分，所有任务可以分成两种，一种是<strong>同步任务（synchronous）</strong>，另一种是<strong>异步任务（asynchronous）</strong>。</p><blockquote><p>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。</p></blockquote><blockquote><p>异步任务指的是，不进入主线程、而进入”任务队列”（task<br>queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p></blockquote><p>总结： <strong>只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制</strong> 。</p><h3 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环 Event Loop"></a>事件循环 Event Loop</h3><p>除了广义的同步任务和异步任务，js 对任务还有更精细的定义：</p><ul><li>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</li><li>micro-task(微任务)：Promise.then、Promise.catch、Promise.finally</li></ul><p><strong>注意</strong></p><p>setTimeout、setInterval宏任务会在下一次宏任务时执行。</p><p><strong>执行规则</strong></p><p>js会先执行整体的同步代码（宏任务），执行过程中，遇到宏任务将宏任务添加到宏任务队列，遇到微任务将微任务添加到微任务队列，直到同步代码执行完。同步代码执行完后，会优先执行微任务队列中的所有任务，完成后再执行下一个宏任务，如此循环。</p><p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。</p><p><a href="images/事件循环机制.png" data-fancybox="group" data-caption class="fancybox"><img src="images/事件循环机制.png" alt title></a></p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>做题前友情提示</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(fn1).then(fn2)</span><br></pre></td></tr></table></figure></div><p>以上代码中 <code>new Promise(fn1)</code> 部分为宏任务，<code>fn1</code> 函数会立即执行，而 <code>.then(fn2)</code> 部分为微任务，会添加到微任务队列。</p><p><strong>习题一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        resolve(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    resolve(<span class="number">2</span>)</span><br><span class="line">    p.then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arg)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">first().then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 7 4 1 2 5</span></span><br></pre></td></tr></table></figure></div><p><strong>习题二</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"0"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1"</span>)</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"2"</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"3"</span>)</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"4"</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"5"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"6"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"7"</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"8"</span>)</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 7 2 3 8 4 6 5 0</span></span><br></pre></td></tr></table></figure></div><p>该题考点：每次.then() 都会new Promise()</p><p><strong>习题三</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="built_in">console</span>.log.bind(<span class="literal">null</span>,<span class="number">1</span>), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="built_in">console</span>.log.bind(<span class="literal">null</span>,<span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    f2()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">    f1()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f3()</span><br><span class="line">f4()</span><br><span class="line"><span class="comment">// 依次打印4，3，2，1</span></span><br></pre></td></tr></table></figure></div><p>该题考点：setTimeout是一个新的宏任务</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;面试常会问，&lt;strong&gt;为什么js是单线程？为什么需要异步？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;假设js是多线程，我们让
      
    
    </summary>
    
      <category term="技术" scheme="http://wenf.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="js" scheme="http://wenf.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>node实现前端项目自动化部署</title>
    <link href="http://wenf.top/2020/08/06/node%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <id>http://wenf.top/2020/08/06/node实现前端项目自动化部署/</id>
    <published>2020-08-06T08:23:09.000Z</published>
    <updated>2021-03-22T01:06:45.482Z</updated>
    
    <content type="html"><![CDATA[<h3 id="传统的手工部署"><a href="#传统的手工部署" class="headerlink" title="传统的手工部署"></a>传统的手工部署</h3><hr><ol><li>打包，本地运行npm run build打包生成dist文件夹。</li><li>ssh连接服务器，切换路径到web对应目录下。</li><li>上传代码到web目录，一般通过xshell或者xftp完成。</li></ol><p><a href="https://s1.ax1x.com/2020/08/06/agWs5d.png" data-fancybox="group" data-caption="image" class="fancybox"><img src="https://s1.ax1x.com/2020/08/06/agWs5d.png" alt="image" title="image"></a></p><p>传统的手工部署存在以下缺点：</p><ol><li>每次都需要打开xshell软件与服务器建立连接。</li><li>当负责多个项目且每个项目都具有测试环境和线上环境时，容易引起部署错误。</li></ol><h3 id="实现自动化部署流程"><a href="#实现自动化部署流程" class="headerlink" title="实现自动化部署流程"></a>实现自动化部署流程</h3><hr><h5 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h5><ol><li>读取配置文件，包含服务器host、port、web目录及本地目录等信息</li><li>本地打包，npm run build生成dist包</li><li>打包成zip，使用archiver将dist包打包成dist.zip</li><li>连接服务器，node-ssh读取配置连接服务器</li><li>上传zip，使用ssh.putFile上传dist.zip</li><li>解压缩zip，使用ssh.execCommand解压dist.zip</li><li>删除本地dist.zip，使用fs.unlink删除本地dist.zip</li></ol><p><a href="https://s1.ax1x.com/2020/08/06/agW6PA.png" data-fancybox="group" data-caption="image" class="fancybox"><img src="https://s1.ax1x.com/2020/08/06/agW6PA.png" alt="image" title="image"></a></p><h5 id="node中运行指令"><a href="#node中运行指令" class="headerlink" title="node中运行指令"></a>node中运行指令</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child_process包可用于执行shell指令</span></span><br><span class="line"><span class="keyword">const</span> childProcess = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line">childProcess.execSync(<span class="string">'npm run build'</span>);</span><br></pre></td></tr></table></figure></div><h5 id="文件打包成zip（archiver）"><a href="#文件打包成zip（archiver）" class="headerlink" title="文件打包成zip（archiver）"></a>文件打包成zip（archiver）</h5><p>archiver用于打包文件生成zip、rar等</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">typescript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> archiver = <span class="built_in">require</span>(<span class="string">'archiver'</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 设置压缩类型及级别</span></span><br><span class="line"> <span class="keyword">const</span> archive = archiver(<span class="string">'zip'</span>, &#123;</span><br><span class="line">   zlib: &#123; level: <span class="number">9</span> &#125;,</span><br><span class="line"> &#125;).on(<span class="string">'error'</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">throw</span> err;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 创建文件输出流</span></span><br><span class="line"> <span class="keyword">const</span> output = fs.createWriteStream(__dirname + <span class="string">'/dist.zip'</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 通过管道方法将输出流存档到文件</span></span><br><span class="line"> archive.pipe(output);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 从subdir子目录追加内容并重命名</span></span><br><span class="line"> archive.directory(<span class="string">'subdir/'</span>, <span class="string">'new-subdir'</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 完成打包归档</span></span><br><span class="line"> archive.finalize();</span><br></pre></td></tr></table></figure></div><h5 id="连接远程服务（node-ssh）"><a href="#连接远程服务（node-ssh）" class="headerlink" title="连接远程服务（node-ssh）"></a>连接远程服务（node-ssh）</h5><p>node-ssh是一个基于ssh2的轻量级npm包，主要用于ssh连接服务器、上传文件、执行命令。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node_ssh = <span class="built_in">require</span>(<span class="string">'node-ssh'</span>)</span><br><span class="line"><span class="keyword">const</span> ssh = <span class="keyword">new</span> node_ssh()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接服务器</span></span><br><span class="line">ssh.connect(&#123;</span><br><span class="line">  host: <span class="string">'localhost'</span>,</span><br><span class="line">  username: <span class="string">'steel'</span>,</span><br><span class="line">  privateKey: <span class="string">'/home/steel/.ssh/id_rsa'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传文件</span></span><br><span class="line">  ssh.putFile(<span class="string">'/home/steel/Lab/localPath'</span>, <span class="string">'/home/steel/Lab/remotePath'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"The File thing is done"</span>)</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Something's wrong"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在远程服务执行命令</span></span><br><span class="line">  ssh.execCommand(<span class="string">'hh_client --json'</span>, &#123; <span class="attr">cwd</span>:<span class="string">'/var/www'</span> &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'STDOUT: '</span> + result.stdout)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'STDERR: '</span> + result.stderr)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></div><h5 id="具体实现代码"><a href="#具体实现代码" class="headerlink" title="具体实现代码"></a>具体实现代码</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deploy.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> childProcess = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">const</span> ora = <span class="built_in">require</span>(<span class="string">'ora'</span>);</span><br><span class="line"><span class="keyword">const</span> node_ssh = <span class="built_in">require</span>(<span class="string">'node-ssh'</span>);</span><br><span class="line"><span class="keyword">const</span> archiver = <span class="built_in">require</span>(<span class="string">'archiver'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; successLog, errorLog, underlineLog &#125; = <span class="built_in">require</span>(<span class="string">'../utils/index'</span>);</span><br><span class="line"><span class="keyword">const</span> projectDir = process.cwd();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ssh = <span class="keyword">new</span> node_ssh(); <span class="comment">// 生成ssh实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 部署流程入口</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">deploy</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; script, webDir, distPath, projectName, name &#125; = config;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    execBuild(script);</span><br><span class="line">    <span class="keyword">await</span> startZip(distPath);</span><br><span class="line">    <span class="keyword">await</span> connectSSH(config);</span><br><span class="line">    <span class="keyword">await</span> uploadFile(webDir);</span><br><span class="line">    <span class="keyword">await</span> unzipFile(webDir);</span><br><span class="line">    <span class="keyword">await</span> deleteLocalZip();</span><br><span class="line">    successLog(<span class="string">`\n 恭喜您，<span class="subst">$&#123;underlineLog(projectName)&#125;</span>项目<span class="subst">$&#123;underlineLog(name)&#125;</span>部署成功了^_^\n`</span>);</span><br><span class="line">    process.exit(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    errorLog(<span class="string">`  部署失败 <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一步，执行打包脚本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execBuild</span>(<span class="params">script</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`\n（1）<span class="subst">$&#123;script&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">const</span> spinner = ora(<span class="string">'正在打包中'</span>);</span><br><span class="line">    spinner.start();</span><br><span class="line">    <span class="built_in">console</span>.log();</span><br><span class="line">    childProcess.execSync(script, &#123; <span class="attr">cwd</span>: projectDir &#125;);</span><br><span class="line">    spinner.stop();</span><br><span class="line">    successLog(<span class="string">'  打包成功'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    errorLog(err);</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二部，打包zip</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startZip</span>(<span class="params">distPath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    distPath = path.resolve(projectDir, distPath);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'（2）打包成zip'</span>);</span><br><span class="line">    <span class="keyword">const</span> archive = archiver(<span class="string">'zip'</span>, &#123;</span><br><span class="line">      zlib: &#123; <span class="attr">level</span>: <span class="number">9</span> &#125;,</span><br><span class="line">    &#125;).on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> output = fs.createWriteStream(<span class="string">`<span class="subst">$&#123;projectDir&#125;</span>/dist.zip`</span>);</span><br><span class="line">    output.on(<span class="string">'close'</span>, err =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        errorLog(<span class="string">`  关闭archiver异常 <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">        reject(err);</span><br><span class="line">        process.exit(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      successLog(<span class="string">'  zip打包成功'</span>);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;);</span><br><span class="line">    archive.pipe(output);</span><br><span class="line">    archive.directory(distPath, <span class="string">'/'</span>);</span><br><span class="line">    archive.finalize();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三步，连接SSH</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">connectSSH</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; host, port, username, password, privateKey, passphrase, distPath &#125; = config;</span><br><span class="line">  <span class="keyword">const</span> sshConfig = &#123;</span><br><span class="line">    host,</span><br><span class="line">    port,</span><br><span class="line">    username,</span><br><span class="line">    password,</span><br><span class="line">    privateKey,</span><br><span class="line">    passphrase</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`（3）连接<span class="subst">$&#123;underlineLog(host)&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">await</span> ssh.connect(sshConfig);</span><br><span class="line">    successLog(<span class="string">'  SSH连接成功'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    errorLog(<span class="string">`  连接失败 <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四部，上传zip包</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">uploadFile</span>(<span class="params">webDir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`（4）上传zip至目录<span class="subst">$&#123;underlineLog(webDir)&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">await</span> ssh.putFile(<span class="string">`<span class="subst">$&#123;projectDir&#125;</span>/dist.zip`</span>, <span class="string">`<span class="subst">$&#123;webDir&#125;</span>/dist.zip`</span>);</span><br><span class="line">    successLog(<span class="string">'  zip包上传成功'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    errorLog(<span class="string">`  zip包上传失败 <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行命令</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">runCommand</span>(<span class="params">command, webDir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> ssh.execCommand(command, &#123; <span class="attr">cwd</span>: webDir &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第五步，解压zip包</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">unzipFile</span>(<span class="params">webDir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'（5）开始解压zip包'</span>);</span><br><span class="line">    <span class="keyword">await</span> runCommand(<span class="string">`cd <span class="subst">$&#123;webDir&#125;</span>`</span>, webDir);</span><br><span class="line">    <span class="keyword">await</span> runCommand(<span class="string">'unzip -o dist.zip &amp;&amp; rm -f dist.zip'</span>, webDir);</span><br><span class="line">    successLog(<span class="string">'  zip包解压成功'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    errorLog(<span class="string">`  zip包解压失败 <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第六步，删除本地dist.zip包</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">deleteLocalZip</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'（6）开始删除本地zip包'</span>);</span><br><span class="line">    fs.unlink(<span class="string">`<span class="subst">$&#123;projectDir&#125;</span>/dist.zip`</span>, err =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        errorLog(<span class="string">`  本地zip包删除失败 <span class="subst">$&#123;err&#125;</span>`</span>, err);</span><br><span class="line">        reject(err);</span><br><span class="line">        process.exit(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      successLog(<span class="string">'  本地dist.zip删除成功\n'</span>);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = deploy;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;传统的手工部署&quot;&gt;&lt;a href=&quot;#传统的手工部署&quot; class=&quot;headerlink&quot; title=&quot;传统的手工部署&quot;&gt;&lt;/a&gt;传统的手工部署&lt;/h3&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;打包，本地运行npm run build打包生成dist文件夹。&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://wenf.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="部署" scheme="http://wenf.top/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>原型和原型链</title>
    <link href="http://wenf.top/2020/08/04/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://wenf.top/2020/08/04/原型和原型链/</id>
    <published>2020-08-04T07:56:41.000Z</published>
    <updated>2021-03-24T08:12:20.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用构造函数创建对象"><a href="#使用构造函数创建对象" class="headerlink" title="使用构造函数创建对象"></a>使用构造函数创建对象</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'tom'</span>)</span><br></pre></td></tr></table></figure></div><p>以上例子，Person 是一个构造函数，使用 new 创建了一个实例对象 person1。</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><strong>什么是原型？</strong></p><p>每个js对象（null除外）在创建的时候，都会关联一个对象，该对象就是实例对象的原型。每一个实例对象都会从原型’继承’属性。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'tom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1.name) <span class="comment">// tom</span></span><br></pre></td></tr></table></figure></div></p><p><strong>如何获取对象的原型？</strong></p><ul><li><p>方式一：构造函数的 <code>prototype</code> 属性</p><p>每个函数都有 <code>prototype</code> 属性（仅函数有该属性），他指向一个对象，该对象是调用了构造函数创建出来的实例的原型。</p><p>上个例子中，<code>Person.prototype</code> 是 person1 的原型。</p></li><li><p>方式二：实例对象的 <code>__proto__</code> 属性</p><p>js中每个对象都拥有 <code>__proto__</code> 属性，该属性指向构造函数的 <code>prototype</code> ，也就是该对象的原型。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div></li></ul><p><strong>从原型能否获取构造函数、实例对象？</strong></p><p>先说明，无法从原型上获取到实例对象；</p><p>原型上可以获取到构造函数。原型有 <code>constructor</code> 属性，指向构造函数。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person === Person.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>构造函数、原型、实例对象间的关系</p><p><a href="./image/prototype3.png" data-fancybox="group" data-caption class="fancybox"><img src="./image/prototype3.png" alt title></a><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ == Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == Person) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><strong>什么是原型链</strong></p><p>当获取实例对象的属性时，会先在实例对象上查找，若没找到则继续在实例对象的原型上查找，若还是没找到继续往原型的原型去查找，直到最顶层。</p><p>这么一条查找的链路叫做 <code>原型链</code>。</p><p><strong>原型的原型是什么？</strong></p><p>上面说过，原型是一个对象，所以我们可以用最原始方式来创建它：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">'Kevin'</span></span><br></pre></td></tr></table></figure></div></p><p>其实原型是通过 <code>Object</code> 构造函数声明的，原型的原型最终会指向 <code>Object.prototype</code> 原型，而该原型的原型指向 <code>null</code>，到此原型链结束。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.__proto__ <span class="comment">// null</span></span><br></pre></td></tr></table></figure></div><p>原型及原型链它们最终关系图（蓝色为原型链路）。</p><p><a href="./image/prototype5.png" data-fancybox="group" data-caption class="fancybox"><img src="./image/prototype5.png" alt title></a></p><h2 id="js中继承的几种方法"><a href="#js中继承的几种方法" class="headerlink" title="js中继承的几种方法"></a>js中继承的几种方法</h2><p>有一个 Parent 构造函数</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.sex = <span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们可以用以下几种方式来实现父类 Parent 的继承，并比较他们的利弊</p><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>通过构造函数创建实例，实例可以继承构造函数和原型的属性。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Parent()</span><br><span class="line"><span class="built_in">console</span>.log(c.sex); <span class="comment">// 男</span></span><br><span class="line"><span class="built_in">console</span>.log(c.say()); <span class="comment">// hello</span></span><br><span class="line"><span class="built_in">console</span>.log(p <span class="keyword">instanceof</span> Parent); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div></p><p>实例继承了构造函数的 sex 属性和原型的 say 属性。</p><h3 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h3><p>在子类的构造函数中执行父类的构造函数，从而实现构造函数的属性继承。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(c.sex); <span class="comment">// 男</span></span><br><span class="line"><span class="built_in">console</span>.log(c.say()); <span class="comment">// Uncaught TypeError: c.say is not a function</span></span><br></pre></td></tr></table></figure></div></p><p><strong>缺点：实例仅继承了 Parent 构造函数的属性，未继承原型上的属性。</strong></p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承其实就是结合前面两种继承方式的继承<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(c.sex); <span class="comment">// 男</span></span><br><span class="line"><span class="built_in">console</span>.log(c.say()); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure></div></p><p>实例拥有sex属性和say方法，继承了构造函数和原型的属性。</p><p>**缺点：调用了两次 Parent；实例的原型上的构造方法属性 Child.prototype.constructor 指向的是 Parent 。</p><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">  F.prototype = obj</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = createAnother(<span class="keyword">new</span> Parent())</span><br></pre></td></tr></table></figure></div><p>es6写法<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.create(obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = createAnother(<span class="keyword">new</span> Parent())</span><br></pre></td></tr></table></figure></div></p><p><strong>缺点：</strong></p><ol><li>如果父类是构造函数，无法继承构造函数属性，无法向构造函数传参；</li><li>如果要继承的是普通对象，对象上的复杂属性会被实例共用；</li></ol><h3 id="寄生式继承-常用"><a href="#寄生式继承-常用" class="headerlink" title="寄生式继承(常用)"></a>寄生式继承(常用)</h3><p>寄生式继承就是在原型式继承的前提上增加额外属性。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(obj);</span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><p><strong>缺点跟原型式继承一样</strong></p><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line">Child.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>使用<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Child(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(c.sex); <span class="comment">// 男</span></span><br><span class="line"><span class="built_in">console</span>.log(c.age); <span class="comment">// 10</span></span><br><span class="line">c.say() <span class="comment">// hello</span></span><br><span class="line">c.sayAge() <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></div></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用构造函数创建对象&quot;&gt;&lt;a href=&quot;#使用构造函数创建对象&quot; class=&quot;headerlink&quot; title=&quot;使用构造函数创建对象&quot;&gt;&lt;/a&gt;使用构造函数创建对象&lt;/h2&gt;&lt;div class=&quot;code-area-wrap&quot;&gt;&lt;div class=&quot;h
      
    
    </summary>
    
      <category term="技术" scheme="http://wenf.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="js" scheme="http://wenf.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js数据类型判断</title>
    <link href="http://wenf.top/2020/06/05/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
    <id>http://wenf.top/2020/06/05/js数据类型判断/</id>
    <published>2020-06-05T07:58:53.000Z</published>
    <updated>2021-03-24T08:14:59.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础数据类型判断"><a href="#基础数据类型判断" class="headerlink" title="基础数据类型判断"></a>基础数据类型判断</h2><p><strong>使用 typeof 操作符判断基础数据类型</strong></p><p>引用《javascript权威指南》对 <code>typeof</code> 的介绍</p><blockquote><p>typeof 是一元操作符，放在其单个操作数的前面，操作数可以是任意类型。返回值为表示操作数类型的一个字符串。</p></blockquote><p>如果不对 <code>object</code> 类型展开，那么在es6之前，js 有6中数据类型。</p><ul><li>string</li><li>number</li><li>boolean</li><li>undefined</li><li>null</li><li>object</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'hello world'</span>) <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">1</span>) <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>) <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;) <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null其实属于对象类型下的一种子类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>) <span class="comment">// objec</span></span><br><span class="line"><span class="comment">// 常用的数组类型也一样</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []) <span class="comment">// object</span></span><br></pre></td></tr></table></figure></div><p><strong>小结</strong>： <code>typeof</code> 能判断基础数据类型，但无法判断复杂数据类型。</p><h2 id="复杂数据类型判断"><a href="#复杂数据类型判断" class="headerlink" title="复杂数据类型判断"></a>复杂数据类型判断</h2><p>Object 下细分了许多复杂类型</p><ul><li>Date</li><li>Array</li><li>Error</li><li>Function</li><li>Regexp</li></ul><p>以上数据类型使用 <code>typeof</code> 判断都返回 <code>object</code>。</p><p>使用更强大的判断方法来判断复杂数据类型</p><p> <strong><code>Object.prototype.toString</code></strong></p><p> 它几乎可以判断所有的数据类型。</p><p><strong>ES5 规范对它的描述</strong></p><p><a href="https://es5.github.io/#x15.2.4.2" target="_blank" rel="noopener">Object.prototype.toString</a></p><blockquote><p>When the toString method is called, the following steps are taken:</p></blockquote><blockquote><ol><li>If the this value is undefined, return <strong>“[object Undefined]”</strong>.</li><li>If the this value is null, return <strong>“[object Null]”</strong>.</li><li>Let O be the result of calling ToObject passing the this value as the argument.</li><li>Let class be the value of the <strong>[[Class]]</strong> internal property of O.</li><li>Return the String value that is the result of concatenating the three Strings <strong>“[object “, class, and “]”</strong>.</li></ol></blockquote><p>通过规范，可以了解到 <strong><code>Object.prototype.toString</code></strong> 会返回如下字符串</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class 是要判断的数据的内部属性，其他部分为固定string</span></span><br><span class="line"><span class="string">`[obejct <span class="subst">$&#123;Class&#125;</span>]`</span></span><br></pre></td></tr></table></figure></div><p>来个demo，看看有多强大</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是14种：</span></span><br><span class="line"><span class="keyword">var</span> number = <span class="number">1</span>;          <span class="comment">// [object Number]</span></span><br><span class="line"><span class="keyword">var</span> string = <span class="string">'123'</span>;      <span class="comment">// [object String]</span></span><br><span class="line"><span class="keyword">var</span> boolean = <span class="literal">true</span>;      <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="keyword">var</span> und = <span class="literal">undefined</span>;     <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="keyword">var</span> nul = <span class="literal">null</span>;          <span class="comment">// [object Null]</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;         <span class="comment">// [object Object]</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];   <span class="comment">// [object Array]</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();   <span class="comment">// [object Date]</span></span><br><span class="line"><span class="keyword">var</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(); <span class="comment">// [object Error]</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/g</span>;          <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// [object Function]</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">Math</span> <span class="comment">// [object Math]</span></span><br><span class="line"><span class="keyword">var</span> json = <span class="built_in">JSON</span> <span class="comment">// [object JSON]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">arguments</span>[i]))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// arguments 也可以判断</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">arguments</span>)) <span class="comment">// [object Arguments]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkType(number, string, boolean, und, nul, obj, array, date, error, reg, func, math, json)</span><br></pre></td></tr></table></figure></div><h2 id="封装一个数据判断方法"><a href="#封装一个数据判断方法" class="headerlink" title="封装一个数据判断方法"></a>封装一个数据判断方法</h2><p><strong>设计：</strong><br>如果是简单类型直接使用 <code>typeof</code> 判断，否则使用 <code>Object.prototype.toString</code> 判断，结果统一使用小写。</p><p><code>@param obj</code> 要判断类型的数据</p><p><code>@return {string}</code> 数据类型（小写）</p><p>通常不会对 arguments 、Math 、JSON 等数据类型判断，所以去掉这些类型。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> type = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 映射类型</span></span><br><span class="line">  <span class="keyword">const</span> classType = <span class="string">'Boolean Number String Function Array Date RegExp Object Error Null Undefined'</span></span><br><span class="line">    .split(<span class="string">' '</span>)</span><br><span class="line">    .reduce(<span class="function">(<span class="params">obj, item</span>) =&gt;</span> &#123;</span><br><span class="line">      obj[<span class="string">'[object '</span> + item + <span class="string">']'</span>] = item.toLowerCase()</span><br><span class="line">      <span class="keyword">return</span> obj</span><br><span class="line">    &#125;, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'object'</span></span><br><span class="line">      ? classType[<span class="built_in">Object</span>.prototype.toString.call(obj)]</span><br><span class="line">      : <span class="keyword">typeof</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// use</span></span><br><span class="line"><span class="built_in">console</span>.log(type(<span class="keyword">new</span> <span class="built_in">Date</span>())) <span class="comment">// date</span></span><br><span class="line"><span class="built_in">console</span>.log(type([<span class="number">1</span>, <span class="number">2</span>])) <span class="comment">// array</span></span><br><span class="line"><span class="built_in">console</span>.log(type(<span class="number">1</span>)) <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(type(&#123;&#125;)) <span class="comment">// object</span></span><br></pre></td></tr></table></figure></div><p>在 IE6 中，null 和 undefined 会被 Object.prototype.toString 识别成 [object Object]！</p><p><strong>兼容处理</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> type = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 映射类型</span></span><br><span class="line">  <span class="keyword">const</span> classType = <span class="string">'Boolean Number String Function Array Date RegExp Object Error Null Undefined'</span></span><br><span class="line">    .split(<span class="string">' '</span>)</span><br><span class="line">    .reduce(<span class="function">(<span class="params">obj, item</span>) =&gt;</span> &#123;</span><br><span class="line">      obj[<span class="string">'[object '</span> + item + <span class="string">']'</span>] = item.toLowerCase()</span><br><span class="line">      <span class="keyword">return</span> obj</span><br><span class="line">    &#125;, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 仅 undefined 与 null 成立</span></span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> obj + <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'object'</span></span><br><span class="line">      ? classType[<span class="built_in">Object</span>.prototype.toString.call(obj)]</span><br><span class="line">      : <span class="keyword">typeof</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></div></p><p><strong>封装独立的数据类型判断</strong></p><p>判断函数<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> type(data) === <span class="string">'function'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><p>判断数组<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isArray = <span class="built_in">Array</span>.isArray || <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> type(data) === <span class="string">'array'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h2 id="拓展：判断空对象"><a href="#拓展：判断空对象" class="headerlink" title="拓展：判断空对象"></a>拓展：判断空对象</h2><p>jQuery 提供了 <code>isEmptyObject</code> 方法判断空对象</p><p><strong>原理</strong>：只要 for 循环有执行，就表示具有属性，有属性即非空对象，否则为空对象。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmptyObject</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name;</span><br><span class="line">  <span class="keyword">for</span> ( name <span class="keyword">in</span> obj ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看出，判断的并不仅仅是空对象</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmptyObject(&#123;&#125;)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmptyObject([])); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmptyObject(<span class="literal">null</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmptyObject(<span class="literal">undefined</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmptyObject(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmptyObject(<span class="string">''</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmptyObject(<span class="literal">true</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div><p>所以可以根据场景，结合使用 <code>type</code> 方法判断.<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmptyObject</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(type(obj) !== <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> name;</span><br><span class="line">  <span class="keyword">for</span> ( name <span class="keyword">in</span> obj ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h2 id="拓展：判断-window-对象"><a href="#拓展：判断-window-对象" class="headerlink" title="拓展：判断 window 对象"></a>拓展：判断 window 对象</h2><p><strong>判断原理</strong>：<code>window</code> 对象有一个window属性指向自己</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWindow</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!data &amp;&amp; data === data.window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="拓展：判断-DOM-元素"><a href="#拓展：判断-DOM-元素" class="headerlink" title="拓展：判断 DOM 元素"></a>拓展：判断 DOM 元素</h2><p><strong>判断原理</strong>：DOM 元素的 <code>nodeType</code> 值为1<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isElement</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!data &amp;&amp; data.nodeType === <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h2 id="拓展：判断数组类型的几种方式比较"><a href="#拓展：判断数组类型的几种方式比较" class="headerlink" title="拓展：判断数组类型的几种方式比较"></a>拓展：判断数组类型的几种方式比较</h2><h3 id="方式一：使用-instanceof-判断"><a href="#方式一：使用-instanceof-判断" class="headerlink" title="方式一：使用 instanceof 判断"></a>方式一：使用 instanceof 判断</h3><p>判断原理：判断数据原型是否为Array。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div><p>弊端一：复杂数据类型 instanceof Object 时都返回true</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div><p>弊端二：修改数据的原型，导致判断错误</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = []</span><br><span class="line">a.__proto__ = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div><h3 id="方式二：使用-Object-原型上的toString方法"><a href="#方式二：使用-Object-原型上的toString方法" class="headerlink" title="方式二：使用 Object 原型上的toString方法"></a>方式二：使用 Object 原型上的toString方法</h3><p>判断原理： Object 原型上的toString方法会返回描述数据类型的字符串</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断数组</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) === <span class="string">'[object Array]'</span></span><br></pre></td></tr></table></figure></div><h3 id="方式三：es5-增加的-Array-isArray"><a href="#方式三：es5-增加的-Array-isArray" class="headerlink" title="方式三：es5 增加的 Array.isArray"></a>方式三：es5 增加的 Array.isArray</h3><p>该方式最为简洁</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray([]) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123;&#125;) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div><p>弊端：由于是es5增加函数，所以不兼容IE8以下浏览器</p><p>可以做如下兼容处理</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(data) === <span class="string">'[object Array]'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>参考：<a href="https://github.com/mqyqingfeng/Blog/issues/28" target="_blank" rel="noopener">JavaScript专题之类型判断(上) #28</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础数据类型判断&quot;&gt;&lt;a href=&quot;#基础数据类型判断&quot; class=&quot;headerlink&quot; title=&quot;基础数据类型判断&quot;&gt;&lt;/a&gt;基础数据类型判断&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;使用 typeof 操作符判断基础数据类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://wenf.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="js" scheme="http://wenf.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>黄金蝴蝶虾</title>
    <link href="http://wenf.top/2020/05/30/%E7%BE%8E%E9%A3%9F-%E9%BB%84%E9%87%91%E8%9D%B4%E8%9D%B6%E8%99%BE/"/>
    <id>http://wenf.top/2020/05/30/美食-黄金蝴蝶虾/</id>
    <published>2020-05-30T03:58:57.000Z</published>
    <updated>2021-03-22T01:06:45.483Z</updated>
    
    <content type="html"><![CDATA[<h3 id="准备食材"><a href="#准备食材" class="headerlink" title="准备食材"></a>准备食材</h3><ul><li>虾</li><li>面包糠</li><li>淀粉</li><li>鸡蛋</li><li>料酒、盐、胡椒粉、姜片</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>把虾洗净，去头去壳</p></li><li><p>把虾开背不要切断，以便入味<br><a href="https://imgchr.com/i/NdZlzd" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/24/NdZlzd.md.jpg" alt="NdZlzd.md.jpg"></a></p></li><li>加料酒、胡椒粉、姜片、盐腌制15分钟<br><a href="https://imgchr.com/i/NdCHXT" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/24/NdCHXT.md.jpg" alt="NdCHXT.md.jpg"></a></li><li>备好三个小碗分别加入面包糠、淀粉、鸡蛋<br><a href="https://imgchr.com/i/NdCY6K" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/24/NdCY6K.png" alt="NdCY6K.png"></a></li><li>先沾淀粉，在沾鸡蛋，在沾面包糠<br><a href="https://imgchr.com/i/NdFPTe" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/24/NdFPTe.md.jpg" alt="NdFPTe.md.jpg"></a></li><li>热锅下油，待冒烟后，将虾下油锅炸成金黄色即可，炸的过程为防止炸糊可以用筷子翻面<br><a href="https://imgchr.com/i/NdEmOx" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/24/NdEmOx.md.jpg" alt="NdEmOx.md.jpg"></a></li></ol><h3 id="自评"><a href="#自评" class="headerlink" title="自评"></a>自评</h3><p>用的食材是冻虾，吃出了鲜虾的口感，味道90分。<br><a href="https://imgchr.com/i/NdCLBF" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/24/NdCLBF.md.jpg" alt="NdCLBF.md.jpg"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;准备食材&quot;&gt;&lt;a href=&quot;#准备食材&quot; class=&quot;headerlink&quot; title=&quot;准备食材&quot;&gt;&lt;/a&gt;准备食材&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;虾&lt;/li&gt;
&lt;li&gt;面包糠&lt;/li&gt;
&lt;li&gt;淀粉&lt;/li&gt;
&lt;li&gt;鸡蛋&lt;/li&gt;
&lt;li&gt;料酒、盐、胡椒粉
      
    
    </summary>
    
      <category term="美食" scheme="http://wenf.top/categories/%E7%BE%8E%E9%A3%9F/"/>
    
    
      <category term="下厨房" scheme="http://wenf.top/tags/%E4%B8%8B%E5%8E%A8%E6%88%BF/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-刻意练习</title>
    <link href="http://wenf.top/2020/03/30/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0/"/>
    <id>http://wenf.top/2020/03/30/读书笔记-刻意练习/</id>
    <published>2020-03-30T07:18:22.000Z</published>
    <updated>2021-03-22T01:06:45.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://s1.ax1x.com/2020/03/30/GmfDij.png" data-fancybox="group" data-caption="刻意练习" class="fancybox"><img src="https://s1.ax1x.com/2020/03/30/GmfDij.png" alt="刻意练习" title="刻意练习"></a></p><p>这本书是著名心理学家 Anders Ericsson 的著作。之所以强调这本书的重要性，是因为在学习的过程中，在跟其他同学沟通的过程中，发现大家学习最常遇到的一个问题：缺乏有效的练习。</p><p><strong>无论学什么，都不能规避《刻意练习》。</strong></p><p><strong>找对了学习方法后，更要坚持《刻意练习》。</strong></p><p>大家都有很多提高效率的学习方法，但是，如果没有你的主观努力，用什么方法都白搭，刻意练习也是一样。</p><p>思维导图介绍：</p><p><a href="https://s1.ax1x.com/2020/03/30/GmWUUJ.png" data-fancybox="group" data-caption="刻意练习思维导图" class="fancybox"><img src="https://s1.ax1x.com/2020/03/30/GmWUUJ.png" alt="刻意练习思维导图" title="刻意练习思维导图"></a></p><h2 id="刻意练习的步骤"><a href="#刻意练习的步骤" class="headerlink" title="刻意练习的步骤"></a>刻意练习的步骤</h2><p><strong>如何才能进行有效的刻意练习呢？</strong></p><blockquote><ol><li>具有定义明确的特定目标</li><li>练习，要专注</li><li>走出舒适区</li><li>刻意练习需要有效反馈</li></ol></blockquote><h3 id="具有定义明确的特定目标"><a href="#具有定义明确的特定目标" class="headerlink" title="具有定义明确的特定目标"></a>具有定义明确的特定目标</h3><p>练习，要有目的。</p><p>如果不给自己制定更明确的目标，很容易在中间就放弃。</p><p>不管是应试还是爱好，目标都要具体化。比如，考过四六级、考研及格，这只是一个总体的目标，仍然不够清晰。</p><p>目标设定：<strong>细分自己的目标，并且可以量化。</strong></p><blockquote><ul><li>比如，为了考研英语考出好成绩，</li><li>完形至少应该拿 8 分；</li><li>阅读至少应该拿 44 分；</li><li>翻译 6 分，作文 22 分。</li><li>然后继续细分，阅读分值最高，我应该怎样攻下阅读。</li></ul></blockquote><h3 id="练习，要专注"><a href="#练习，要专注" class="headerlink" title="练习，要专注"></a>练习，要专注</h3><p>书中列举了记忆学习者法隆的例子，尽管训练的时间不长，但每次训练期间，他的注意力都能高度集中。一开始他只能记住 7 个数字，到实验一半时，他已经能记住 40 个数字了。</p><p><strong>一切在学习期间跟你争夺注意力的东西，都是你的敌人。</strong></p><p>比如你现在看的知乎，手中的手机。</p><p>所以，学习的时候要开启专注模式，当你进入学习的状态后，你会发现原来你可以连续学习十几个小时都不累。来自亲身体验。</p><h3 id="走出舒适区"><a href="#走出舒适区" class="headerlink" title="走出舒适区"></a>走出舒适区</h3><p>舒适区，<strong>comfort zone</strong>，这个概念大家已经见过不止一次两次了。</p><p>不过就像拖延症一样，大家都知道应该这样做，可真到了自己要迈出这一步的时候，又把脚收回去了。</p><p>对于很多同学来说，听力实在是太不舒适的地方了。但是，如果让你听 Good morning，How are you doing? 你肯定没什么问题。</p><p>所以，我不建议大家一开始就大踏步迈到难受的 <strong>panic zone</strong>（恐慌区）里，而是试探性地进入学习区，感受一下。</p><p><a href="https://s1.ax1x.com/2020/03/30/GmWNE4.png" data-fancybox="group" data-caption="GmWNE4.png" class="fancybox"><img src="https://s1.ax1x.com/2020/03/30/GmWNE4.png" alt="GmWNE4.png" title="GmWNE4.png"></a></p><p>大家选择的学习材料要跟自己的水平大致相当，或者稍高出一个档次，这就是 Krashen 提出的 i+1 理论中一个重要观点。</p><p>拿前端编程人员学习后端开发来说：</p><blockquote><ul><li>前端开发工程师，已掌握js语法</li><li>先接触node后端开发（node基于js语法）</li><li>有后端开发经验、思想，再去学习java开发</li><li>循序渐进而不是揠苗助长地去学习</li></ul></blockquote><p><strong>如果墨守成规的一直待在舒适区，就永远无法进步。</strong></p><h3 id="刻意练习需要有效反馈"><a href="#刻意练习需要有效反馈" class="headerlink" title="刻意练习需要有效反馈"></a>刻意练习需要有效反馈</h3><p>书中举了音乐学生的栗子。学生练习很认真，但是似乎没有人给他提供过反馈，没人指出他的错误，所以，他过去做的其实只是重复自己的错误，尽管他专注、努力、有目标，最后还是只拿到了 C 的成绩。</p><p><strong>反馈的来源主要分两类：一类是物，一类是人。</strong></p><p>对于应试的孩子来说，题目的答案可以让你获得即时反馈，自己错了几个，能得多少分。</p><p>对于学习其他技能、方法，比如学习摄影，自己拍的照片好不好，不好在哪儿；自己练习听力只能记住两三个单词，多了就记不住了，原因在哪儿？</p><p>除了自己去探索外，外界，尤其是在这个领域经、资历更丰富的人，往往更容易帮你找到问题的症结。</p><p>《刻意练习》在后面的章节再次强调了老师的重要性，甚至称之为这是成功最重要的事情。</p><blockquote><p>为了你的成功，最重要的一件事情是找一位好导师，并向他请教。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://s1.ax1x.com/2020/03/30/GmfDij.png&quot; data-fancybox=&quot;gro
      
    
    </summary>
    
      <category term="书籍" scheme="http://wenf.top/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="读书笔记" scheme="http://wenf.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>手摸手带你用javascript实现e2e自动化测试</title>
    <link href="http://wenf.top/2020/03/10/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0%E7%94%A8javascript%E5%AE%9E%E7%8E%B0e2e%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    <id>http://wenf.top/2020/03/10/手摸手带你用javascript实现e2e自动化测试/</id>
    <published>2020-03-10T10:34:36.000Z</published>
    <updated>2021-03-22T01:06:45.483Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相关技术栈和工具"><a href="#相关技术栈和工具" class="headerlink" title="相关技术栈和工具"></a>相关技术栈和工具</h3><hr><ul><li><a href="https://cucumber.io/docs/bdd/" target="_blank" rel="noopener">行为驱动开发（BDD）</a>：软件团队工作的一种方式</li><li><a href="https://webdriver.io/" target="_blank" rel="noopener">webdriverio</a>：适用于node的端到端测试框架</li><li><a href="https://cucumber.io/" target="_blank" rel="noopener">cucumber.js</a>：实现BDD开发的框架</li><li><a href="http://www.selenium.org.cn/" target="_blank" rel="noopener">selenium</a>：免费的分布式的自动化测试工具</li><li><a href="https://www.chaijs.com/" target="_blank" rel="noopener">chai</a>：测试中用到的断言工具</li><li><a href="http://cuketest.com/" target="_blank" rel="noopener">cukeTest</a>：快速编辑自动化脚本的编辑器</li><li><a href="https://www.mongodb.org.cn/" target="_blank" rel="noopener">mongodb</a>：数据库，断言会用到</li></ul><p><strong>实现效果：</strong> 自动打开谷歌浏览器，并模拟用户进行操作，测试后生成一份测试报告。</p><p><strong>备注：</strong> ==主要用到wdio（webdriverio简写）框架，wdio内置了cucumber.js、selenium，嫌麻烦重点看wdio和chai说明文档即可。==</p><h4 id="BDD介绍"><a href="#BDD介绍" class="headerlink" title="BDD介绍"></a>BDD介绍</h4><h5 id="什么是BDD？"><a href="#什么是BDD？" class="headerlink" title="什么是BDD？"></a>什么是BDD？</h5><p>BDD是软件团队工作的一种方式，它可以通过以下方式缩小业务人员和技术人员之间的差距：</p><blockquote><ol><li>鼓励跨角色协作以建立对要解决问题的共识</li><li>进行快速，小的迭代，以增加反馈和价值</li><li>生成系统文档，并根据系统行为自动检查</li></ol></blockquote><p>为此，我们将重点放在具体的实际示例上来开展协作工作，这些示例说明了我们希望系统如何运行。在持续的协作过程中，我们使用这些示例来指导我们从概念到实现。</p><h5 id="BDD具体实现"><a href="#BDD具体实现" class="headerlink" title="BDD具体实现"></a>BDD具体实现</h5><p>本质上，日常的BDD活动是一个三步骤的迭代过程：</p><blockquote><ol><li>首先，对系统进行一个小更改命名为“用户故事”，并讨论其新功能的具体测试用例，就预期要做的细节达成一致。</li><li>接下来，以一种可以自动化的方式记录这些测试用例。</li><li>最后，实现每个记录的测试用例所描述的行为，并以实现自动化测试的目标来指导功能代码的开发。</li></ol></blockquote><p>这样做的想法是改动较少的代码并快速迭代，将功能给到测试或产品。每次您自动化并实现一个新示例时，便为应用添加了一些有价值的东西，并得到及时的响应反馈，提高团队开发效率。</p><h3 id="搭建e2e测试框架"><a href="#搭建e2e测试框架" class="headerlink" title="搭建e2e测试框架"></a>搭建e2e测试框架</h3><hr><h4 id="初始化目录结构"><a href="#初始化目录结构" class="headerlink" title="初始化目录结构"></a>初始化目录结构</h4><p><a href="https://s2.ax1x.com/2020/03/10/8iaua4.png" data-fancybox="group" data-caption="自动化测试目录结构" class="fancybox"><img src="https://s2.ax1x.com/2020/03/10/8iaua4.png" alt="自动化测试目录结构" title="自动化测试目录结构"></a></p><h4 id="初始化配置和环境"><a href="#初始化配置和环境" class="headerlink" title="初始化配置和环境"></a>初始化配置和环境</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装wdio依赖，安装后会生成./node_modules/.bin/wdio文件</span></span><br><span class="line">npm i --save-dev @wdio/cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成wdio配置文件。</span></span><br><span class="line"><span class="comment"># 注意：生成配置文件过程会让你选择报告插件、BDD框架、是否开启同步模式、浏览器驱动。</span></span><br><span class="line"><span class="comment"># 我的配置是选择allure-reporter报告、cucumber框架、开启同步模式、chromedriver驱动，选择后会自动安装所需依赖</span></span><br><span class="line">./node_modules/.bin/wdio config -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装断言依赖</span></span><br><span class="line">npm i chai --save-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加启动指令到package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"scripts"</span>: &#123;</span><br><span class="line">        <span class="string">"test:e2e"</span>: <span class="string">"wdio ./test/e2e/wdio.conf.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1.电脑需安装Java 8</span><br><span class="line">2.依赖包chromedriver版本要和chrome浏览器版本一致，否则自动打开浏览器会闪退</span><br><span class="line">3.node需要版本10以上，否则报错</span><br></pre></td></tr></table></figure></div><h5 id="修改wdio配置"><a href="#修改wdio配置" class="headerlink" title="修改wdio配置"></a>修改wdio配置</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将wdio.conf.js移到test/e2e/下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改wdio.conf.js中配置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">exports</span>.config = &#123;</span><br><span class="line">    ...</span><br><span class="line">    path: <span class="string">'/wd/hub'</span>,<span class="comment">// 由于使用chromedriver，此处配置成谷歌服务路径</span></span><br><span class="line">    specs: [</span><br><span class="line">        <span class="string">'./test/e2e/features/*.feature'</span><span class="comment">// 要检索测试用例的路径</span></span><br><span class="line">    ],</span><br><span class="line">    bail: <span class="number">100</span>,<span class="comment">// 运行测试失败对应次数后，停止测试</span></span><br><span class="line">    capabilities: [&#123;</span><br><span class="line">        maxInstances: <span class="number">5</span>,</span><br><span class="line">        browserName: <span class="string">'chrome'</span>,</span><br><span class="line">        <span class="comment">// 配置 无浏览器测试（如不需要将goog:chromeOptions注释）</span></span><br><span class="line">        <span class="string">'goog:chromeOptions'</span>: &#123;</span><br><span class="line">          args: [<span class="string">'--headless'</span>, <span class="string">'--disable-gpu'</span>],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    logLevel: <span class="string">'silent'</span>,<span class="comment">// 日志等级silent简单，info详细</span></span><br><span class="line">    baseUrl: <span class="string">'http://localhost:9528/'</span>,<span class="comment">// 基础路径</span></span><br><span class="line">    services: [<span class="string">'chromedriver'</span>],<span class="comment">// 浏览器驱动</span></span><br><span class="line">    framework: <span class="string">'cucumber'</span>,<span class="comment">// BDD框架</span></span><br><span class="line">    <span class="comment">// 报告生成路径</span></span><br><span class="line">    reporters: [[<span class="string">'allure'</span>, &#123;</span><br><span class="line">        outputDir: <span class="string">'./test/e2e/reports/allure-results/'</span>,</span><br><span class="line">        disableWebdriverStepsReporting: <span class="keyword">true</span>,</span><br><span class="line">        disableWebdriverScreenshotsReporting: <span class="keyword">false</span>,</span><br><span class="line">    &#125;]],</span><br><span class="line">    <span class="comment">// cucumber配置</span></span><br><span class="line">    cucumberOpts: &#123;</span><br><span class="line">        ...</span><br><span class="line">            require: [<span class="string">'./test/e2e/stepDefinitions/**/*.js'</span>],<span class="comment">// 实现步骤代码的路径</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;，</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="测试用例编写和实现"><a href="#测试用例编写和实现" class="headerlink" title="测试用例编写和实现"></a>测试用例编写和实现</h4><h5 id="测试用例编写"><a href="#测试用例编写" class="headerlink" title="测试用例编写"></a>测试用例编写</h5><p>由于上文wdio配置中已配置specs: [‘./test/e2e/features/*.feature’]，<br>所以wdio会检索该目录下的所有feature文件<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">gherkin</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 新建test.feature于目录test/e2e/features/</span><br><span class="line">// 并增加如下内容</span><br><span class="line"></span><br><span class="line"><span class="comment"># 剧本标题</span></span><br><span class="line"><span class="keyword">Feature</span>: 百度使用测试</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 场景名称</span></span><br><span class="line">  <span class="keyword">Scenario</span> <span class="keyword">Outline</span>: 百度标题是否正确</span><br><span class="line">    <span class="comment"># 具体步骤，共有Given、When、Then三个关键词来标识所有步骤</span></span><br><span class="line">    <span class="keyword">When</span> 进入百度网站</span><br><span class="line">    <span class="keyword">Then</span> 网站标题为<span class="string">"&lt;title&gt;"</span></span><br><span class="line">    <span class="comment"># 例子：程序会按照例子中每一行数据来执行场景步骤</span></span><br><span class="line">    <span class="keyword">Examples</span>:</span><br><span class="line">      |<span class="string"> title     </span>|</span><br><span class="line">      |<span class="string"> 百度一下，你就知道 </span>|</span><br></pre></td></tr></table></figure></div></p><h5 id="测试用例自动化的实现"><a href="#测试用例自动化的实现" class="headerlink" title="测试用例自动化的实现"></a>测试用例自动化的实现</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">php</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建hook.js 与目录test/e2e/</span></span><br><span class="line"><span class="comment">// 自动化测试钩子</span></span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  before: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将一些常用api设置成全局变量</span></span><br><span class="line">    <span class="keyword">const</span> chai = <span class="keyword">require</span>(<span class="string">'chai'</span>);</span><br><span class="line">    <span class="keyword">global</span>.expect = chai.expect;</span><br><span class="line">    <span class="keyword">global</span>.assert = chai.assert;</span><br><span class="line">    <span class="keyword">global</span>.should = chai.should();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; Given, When, Then &#125; = <span class="keyword">require</span>(<span class="string">'cucumber'</span>)</span><br><span class="line">    <span class="keyword">global</span>.Given = Given;</span><br><span class="line">    <span class="keyword">global</span>.When = When;</span><br><span class="line">    <span class="keyword">global</span>.Then = Then;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Page = <span class="keyword">require</span>(<span class="string">'./pageObjects/page.js'</span>)</span><br><span class="line">    <span class="keyword">global</span>.global_page = <span class="keyword">new</span> Page();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 每个场景结束后，增加截图展示</span></span><br><span class="line">  afterScenario: <span class="function"><span class="keyword">function</span><span class="params">(scenarioResult)</span> </span>&#123;</span><br><span class="line">    browser.takeScreenshot();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">lasso</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wdio.conf.js</span></span><br><span class="line"><span class="comment">// 将hook导入wdio配置中</span></span><br><span class="line"></span><br><span class="line">const hook = <span class="keyword">require</span>(<span class="string">'./hook'</span>);</span><br><span class="line"></span><br><span class="line">exports.config = &#123;</span><br><span class="line">  <span class="params">...</span></span><br><span class="line">  <span class="comment">// 导入自定义配置</span></span><br><span class="line">  <span class="params">...</span>hook,</span><br><span class="line">  <span class="params">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建given.js、when.js、then.js于目录test/e2e/stepDefinitions/</span></span><br><span class="line"><span class="comment">// feature文件中Given、When、Then步骤的逻辑要在这三个文件中实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// when.js</span></span><br><span class="line"></span><br><span class="line">When(<span class="string">"进入百度网站"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  browser.url(<span class="string">'https://www.baidu.com/'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// then.js</span></span><br><span class="line"></span><br><span class="line">Then(<span class="string">"网站标题为&#123;string&#125;"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">title</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> browserTitle = browser.getTitle();</span><br><span class="line">  expect(browserTitle).to.be.equal(title);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p><strong>其中</strong></p><ul><li><strong>browser</strong>为wdio的全局对象，用来操作浏览器，具体看<a href="https://webdriver.io/docs/api.html" target="_blank" rel="noopener">官网api</a></li><li><strong>expect</strong>为chai断言中的一种，用于预期结果的判断（如上例子判断当前浏览器的标题和例子中’百度一下，你就知道’是相等的）</li></ul><h5 id="执行自动化测试"><a href="#执行自动化测试" class="headerlink" title="执行自动化测试"></a>执行自动化测试</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">dockerfile</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 由于上文已将启动指令添加到package.json中，直接运行即可</span><br><span class="line"></span><br><span class="line">npm <span class="keyword">run</span><span class="bash"> <span class="built_in">test</span>:e2e</span></span><br></pre></td></tr></table></figure></div><p>运行后，浏览器会自动执行步骤，控制台会打印执行日志信息</p><h4 id="输出测试结果报告，并在浏览器展示"><a href="#输出测试结果报告，并在浏览器展示" class="headerlink" title="输出测试结果报告，并在浏览器展示"></a>输出测试结果报告，并在浏览器展示</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">vala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 安装测试报告生成工具</span></span><br><span class="line">npm install -g allure-commandline --save-dev</span><br><span class="line"></span><br><span class="line"><span class="meta"># package.json 中增加scripts指令，用于生成报告</span></span><br><span class="line"><span class="string">"allure-report"</span>: <span class="string">"cd test/e2e/reports &amp;&amp; allure generate --clean ./allure-results &amp;&amp; allure open"</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 生成allure报告，并在浏览器打开（此时不可打开vpn，否则读取不到服务数据）</span></span><br><span class="line"><span class="meta"># 先手动删除test/e2e/reports/allure-results 文件夹，否则有旧的测试缓存</span></span><br><span class="line">npm run allure-report</span><br></pre></td></tr></table></figure></div><p><a href="https://s2.ax1x.com/2020/03/10/8iaKIJ.md.png" data-fancybox="group" data-caption="测试报告" class="fancybox"><img src="https://s2.ax1x.com/2020/03/10/8iaKIJ.md.png" alt="测试报告" title="测试报告"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;相关技术栈和工具&quot;&gt;&lt;a href=&quot;#相关技术栈和工具&quot; class=&quot;headerlink&quot; title=&quot;相关技术栈和工具&quot;&gt;&lt;/a&gt;相关技术栈和工具&lt;/h3&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cucumber.io/docs/b
      
    
    </summary>
    
      <category term="技术" scheme="http://wenf.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="自动化测试" scheme="http://wenf.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript实现浏览器批量打包下载</title>
    <link href="http://wenf.top/2020/02/28/JavaScript%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%B9%E9%87%8F%E6%89%93%E5%8C%85%E4%B8%8B%E8%BD%BD/"/>
    <id>http://wenf.top/2020/02/28/JavaScript实现浏览器批量打包下载/</id>
    <published>2020-02-28T03:15:29.000Z</published>
    <updated>2021-03-22T01:06:45.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关依赖"><a href="#相关依赖" class="headerlink" title="相关依赖"></a>相关依赖</h2><ul><li><a href="https://stuk.github.io/jszip/" target="_blank" rel="noopener">JSZip</a>：用于创建、读取和编辑.zip文件的javascript库</li><li><a href="https://github.com/eligrey/FileSaver.js/" target="_blank" rel="noopener">FileSaver</a>：将文件保存到本地的解决方案</li><li><a href="http://www.axios-js.com/" target="_blank" rel="noopener">axios</a>：Vue推荐的http库</li></ul><h2 id="JSZip浏览器支持"><a href="#JSZip浏览器支持" class="headerlink" title="JSZip浏览器支持"></a>JSZip浏览器支持</h2><table><thead><tr><th>Opera</th><th>Firefox</th><th>Safari</th><th>Chrome</th><th>Internet Explorer</th><th>Node.js</th></tr></thead><tbody><tr><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Tested with the latest version</td><td>Tested with 3.0 / 3.6 / latest version</td><td>Tested with the latest version</td><td>Tested with the latest version</td><td>Tested with IE 6 / 7 / 8 / 9 / 10</td><td>Tested with node.js 0.10 / latest version</td></tr></tbody></table><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> JSZip <span class="keyword">from</span> <span class="string">'jszip'</span>;</span><br><span class="line"><span class="keyword">import</span> FileSaver <span class="keyword">from</span> <span class="string">'file-saver'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zip = <span class="keyword">new</span> JSZip();</span><br><span class="line">zip.file(<span class="string">"Hello.txt"</span>, <span class="string">"Hello World\n"</span>);</span><br><span class="line"><span class="comment">// zip.folder(name):如果目录不存在，创建一个目录，并以新文件夹为根返回一个新的JSZip对象。</span></span><br><span class="line"><span class="keyword">var</span> img = zip.folder(<span class="string">"images"</span>);</span><br><span class="line">img.file(<span class="string">"smile.gif"</span>, imgData, &#123;<span class="attr">base64</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">zip.generateAsync(&#123;<span class="attr">type</span>:<span class="string">"blob"</span>&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将文件保存到本地</span></span><br><span class="line">    FileSaver.saveAs(content, <span class="string">"example.zip"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p><strong>zip.file(name, data, options)</strong>，将文件添加（或更新）到zip文件中。</p><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>name</td><td>string</td><td>文件名。您可以在名称中指定文件夹：文件夹分隔符为正斜杠（“ /”）。</td></tr><tr><td>data</td><td>String/ArrayBuffer/Uint8Array/Buffer/Blob/Promise/Nodejs stream</td><td>文件的内容。</td></tr><tr><td>options</td><td>object</td><td><a href="https://stuk.github.io/jszip/documentation/api_jszip/file_data.html" target="_blank" rel="noopener">配置选项</a></td></tr></tbody></table><p><strong>zip.generateAsync( object )</strong>，在当前文件夹级别生成完整的zip文件。</p><p>其中参数object支持的配置可看<a href="https://stuk.github.io/jszip/documentation/api_jszip/generate_async.html" target="_blank" rel="noopener">官方说明</a>，这边简单说说type配置项。</p><p><strong>可能的值type：</strong></p><ol><li>base64：结果将是一个字符串，二进制格式为base64。</li><li>binarystring（或string已弃用）：结果将是“二进制”形式的字符串，每个字符使用1个字节（2个字节）。</li><li>array：结果将是字节数组（0到255之间的数字）。</li><li>uint8array：结果将是包含Uint8Array的zip。这需要兼容的浏览器。</li><li>arraybuffer：结果将是一个包含ArrayBuffer的zip。这需要兼容的浏览器。</li><li>blob：结果将是包含Blob的zip。这需要兼容的浏览器。</li><li>nodebuffer：结果将是包含nodebuffer的zip。这需要nodejs。</li></ol><h2 id="结合axios实现批量打包下载"><a href="#结合axios实现批量打包下载" class="headerlink" title="结合axios实现批量打包下载"></a>结合axios实现批量打包下载</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">typescript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> JSZip <span class="keyword">from</span> <span class="string">'jszip'</span>;</span><br><span class="line"><span class="keyword">import</span> FileSaver <span class="keyword">from</span> <span class="string">'file-saver'</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加getFile方法异步获取远程资源</span></span><br><span class="line">getFile(url) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      axios(&#123;</span><br><span class="line">        method: <span class="string">'get'</span>,</span><br><span class="line">        url,</span><br><span class="line">        responseType: <span class="string">'blob'</span></span><br><span class="line">      &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">          resolve(data);</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">compressedFiles(allUrl) &#123;</span><br><span class="line">    <span class="keyword">const</span> zip = <span class="keyword">new</span> JSZip();</span><br><span class="line">    <span class="keyword">const</span> promises = [];</span><br><span class="line">    </span><br><span class="line">    allUrl.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> promise = <span class="keyword">this</span>.getFile(item).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 获取文件名</span></span><br><span class="line">        zip.file(<span class="string">`name&#123;index&#125;`</span>, data.data); <span class="comment">// 逐个添加文件</span></span><br><span class="line">      &#125;);</span><br><span class="line">      promises.push(promise);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      zip.generateAsync(&#123; <span class="keyword">type</span>: <span class="string">'blob'</span> &#125;).then(<span class="function"><span class="params">content</span> =&gt;</span> &#123;</span><br><span class="line">        FileSaver.saveAs(content, <span class="string">'压缩文件.zip'</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// use</span></span><br><span class="line"><span class="keyword">this</span>.compressedFiles([<span class="string">'http://path1'</span>,<span class="string">'http://path2'</span>]);</span><br></pre></td></tr></table></figure></div><p><strong>这就对远程资源实现批量打包下载啦！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;相关依赖&quot;&gt;&lt;a href=&quot;#相关依赖&quot; class=&quot;headerlink&quot; title=&quot;相关依赖&quot;&gt;&lt;/a&gt;相关依赖&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://stuk.github.io/jszip/&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
      <category term="技术" scheme="http://wenf.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="文件打包" scheme="http://wenf.top/tags/%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>卤鸡腿</title>
    <link href="http://wenf.top/2019/11/24/%E7%BE%8E%E9%A3%9F-%E5%8D%A4%E9%B8%A1%E8%85%BF/"/>
    <id>http://wenf.top/2019/11/24/美食-卤鸡腿/</id>
    <published>2019-11-24T08:48:09.000Z</published>
    <updated>2021-03-22T01:06:45.483Z</updated>
    
    <content type="html"><![CDATA[<h3 id="准备食材"><a href="#准备食材" class="headerlink" title="准备食材"></a>准备食材</h3><ul><li>解冻鸡腿</li><li>辣椒</li><li>葱头</li><li>大蒜</li><li>姜</li><li>生抽、老抽、料酒、盐巴、味精</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>给解冻鸡腿焯水，完后放入冷水浸泡</li><li>用牙签给鸡腿扎孔，觉得麻烦用刀切几个口子也行</li><li>起锅热油，油热后开小火，再放入辣椒、葱头、大蒜、生抽、老抽、料酒炒香</li><li>加入鸡腿翻炒60s</li><li>加入快淹没鸡腿的清水焖几分钟，放入盐巴、味精翻炒在焖几分钟，直至汤汁被吸收即可出锅。</li></ol><p><strong>让人欲罢不能的卤鸡腿就制作完成啦！</strong></p><p><a href="https://s2.ax1x.com/2020/02/29/3yycoF.md.jpg" data-fancybox="group" data-caption="image" class="fancybox"><img src="https://s2.ax1x.com/2020/02/29/3yycoF.md.jpg" alt="image" title="image"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;准备食材&quot;&gt;&lt;a href=&quot;#准备食材&quot; class=&quot;headerlink&quot; title=&quot;准备食材&quot;&gt;&lt;/a&gt;准备食材&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;解冻鸡腿&lt;/li&gt;
&lt;li&gt;辣椒&lt;/li&gt;
&lt;li&gt;葱头&lt;/li&gt;
&lt;li&gt;大蒜&lt;/li&gt;
&lt;li&gt;姜&lt;/li&gt;
      
    
    </summary>
    
      <category term="美食" scheme="http://wenf.top/categories/%E7%BE%8E%E9%A3%9F/"/>
    
    
      <category term="下厨房" scheme="http://wenf.top/tags/%E4%B8%8B%E5%8E%A8%E6%88%BF/"/>
    
  </entry>
  
  <entry>
    <title>剁椒鱼头（超级简单）</title>
    <link href="http://wenf.top/2019/11/23/%E7%BE%8E%E9%A3%9F-%E5%89%81%E6%A4%92%E9%B1%BC%E5%A4%B4/"/>
    <id>http://wenf.top/2019/11/23/美食-剁椒鱼头/</id>
    <published>2019-11-23T08:48:09.000Z</published>
    <updated>2021-03-22T01:06:45.483Z</updated>
    
    <content type="html"><![CDATA[<h3 id="准备食材"><a href="#准备食材" class="headerlink" title="准备食材"></a>准备食材</h3><ul><li>鲢鱼头一个（大超市有卖，一斤15元）</li><li>剁椒（超市罐装剁椒即可）</li><li>葱花</li><li>姜</li><li>酱油</li><li>小捆粉（煮火锅那种小捆的米粉）</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>切葱花姜片，鱼头对半切开</li><li>摆盘，将小捆粉摆在盘底，鱼头正面抄上摆好，将剁椒葱姜撒到鱼头表面</li><li>蒸煮十分钟即可出锅，出锅后撒上些许酱油</li></ol><p><strong>香喷喷的剁椒鱼头就制作完成啦！</strong></p><p><a href="https://s2.ax1x.com/2020/02/29/3yyDs0.md.jpg" data-fancybox="group" data-caption="image" class="fancybox"><img src="https://s2.ax1x.com/2020/02/29/3yyDs0.md.jpg" alt="image" title="image"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;准备食材&quot;&gt;&lt;a href=&quot;#准备食材&quot; class=&quot;headerlink&quot; title=&quot;准备食材&quot;&gt;&lt;/a&gt;准备食材&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;鲢鱼头一个（大超市有卖，一斤15元）&lt;/li&gt;
&lt;li&gt;剁椒（超市罐装剁椒即可）&lt;/li&gt;
&lt;li&gt;葱花&lt;/li
      
    
    </summary>
    
      <category term="美食" scheme="http://wenf.top/categories/%E7%BE%8E%E9%A3%9F/"/>
    
    
      <category term="下厨房" scheme="http://wenf.top/tags/%E4%B8%8B%E5%8E%A8%E6%88%BF/"/>
    
  </entry>
  
  <entry>
    <title>html5拖放</title>
    <link href="http://wenf.top/2019/04/14/drag-drop/"/>
    <id>http://wenf.top/2019/04/14/drag-drop/</id>
    <published>2019-04-14T08:19:42.000Z</published>
    <updated>2021-03-22T01:06:45.482Z</updated>
    
    <content type="html"><![CDATA[<hr><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=139774&auto=0&height=66"></iframe><hr><h1 id="H5-拖放"><a href="#H5-拖放" class="headerlink" title="H5 拖放"></a>H5 拖放</h1><h3 id="1-浏览器支持："><a href="#1-浏览器支持：" class="headerlink" title="1.浏览器支持："></a>1.浏览器支持：</h3><p>IE 9以上、Firefox、Opera、Chrome以及Safari 12支持拖放</p><h3 id="2-拖放组成部分："><a href="#2-拖放组成部分：" class="headerlink" title="2.拖放组成部分："></a>2.拖放组成部分：</h3><p>分为两部分： 拖拽<strong>drag</strong> 和 释放 <strong>drop</strong></p><p>可以理解为：</p><p>源对象=&gt;拖动的元素；</p><p>目标对象=&gt;接收被拖动目标的元素</p><p><a href="https://img-blog.csdn.net/20180610141232779" data-fancybox="group" data-caption class="fancybox"><img src="https://img-blog.csdn.net/20180610141232779" alt title></a></p><h3 id="3-API"><a href="#3-API" class="headerlink" title="3.API"></a>3.API</h3><ul><li><p>设置元素为可拖放</p><p>  <code>&lt;img draggable=&quot;true&quot;/&gt;</code></p></li><li><p>被拖动的源对象可以触发的事件</p><ol><li><p>ondragstart：源对象开始被拖动</p></li><li><p>ondrag：源对象被拖动过程中(鼠标可能在移动也可能未移动)</p></li><li><p>ondragend：源对象被拖动结束</p></li></ol></li><li><p>目标对象可以触发的事件</p><ol><li><p>ondragenter：目标对象被源对象拖动着进入</p></li><li><p>ondragover：目标对象被源对象拖动着悬停在上方</p></li><li><p>ondragleave：源对象拖动着离开了目标对象</p></li><li><p>ondrop：源对象拖动着在目标对象上方释放/松手</p></li></ol></li><li><p>源对象事件和目标对象事件间传递数据</p><p>  HTML5为所有的拖动相关事件提供了一个新的属性dataTransfer用于数据传递。</p><p>  使用：</p><pre><code>源对象设置值：// key为设置值的名称，value为具体值（两个参数必须为string类型）e.dataTransfer.setData( key, value);目标对象获取值：// key为设置值的名称e.dataTransfer.getData( key);</code></pre></li></ul><h3 id="4-demo"><a href="#4-demo" class="headerlink" title="4.demo"></a>4.demo</h3><p>开始动手前，把系统的默认事件阻止，否则部分API的事件无法触发。</p><pre><code>window.onload = function () {    //监听document的drop事件——取消其默认行为：在新窗口中打开图片    document.ondragover = function(e){        e.preventDefault(); //使得drop事件可以触发    }    document.ondrop = function(e) {        e.preventDefault(); //阻止在新窗口中打开图片，否则仍然会执行下载操作！！！    }}</code></pre><p>上个简单的例子：<strong>基础拖拽</strong></p><pre><code>html：       &lt;div id=&quot;drag&quot;             class=&quot;drag&quot;             onselectstart=&quot;return false&quot;             ondragstart=&quot;drag(event)&quot;             draggable=&quot;true&quot;&gt;被拖拽元素&lt;/div&gt;        &lt;div id=&quot;drop&quot;             ondrop=&quot;drop(event)&quot;             class=&quot;drop&quot;&gt;接收拖拽元素&lt;/div&gt;js:        function drag(e) {            let self = e.target;            // 传递当前拖拽id            e.dataTransfer.setData(&apos;dragId&apos;,self.id);        }        function drop(e) {            let self = e.target,                dragId = e.dataTransfer.getData(&apos;dragId&apos;);// 接收id            self.appendChild(document.getElementById(dragId));// 插入节点        }</code></pre><p>效果：<a href="https://wenfujie.github.io/document-library/js-library/H5-drag-drop/%E6%8B%96%E6%8B%BDdemo-%E5%9F%BA%E7%A1%80%E7%89%88.html" target="_blank" rel="noopener"><strong>Demo</strong></a></p><p>再来一个：<strong>拖拽批量上传图片</strong></p><p><strong>备注</strong>：仅需ondrop事件，以下用到ondragenter和ondragleave是用于修改样式，<br>还需用到H5文件处理API。</p><pre><code>html：    &lt;p&gt;将电脑图片拖到下方即可上传&lt;/p&gt;    &lt;div class=&quot;up-area&quot;         ondragenter=&quot;dragEnter(event)&quot;         ondragleave=&quot;dragLeave(event)&quot;         ondrop=&quot;getImg(event)&quot;&gt;&lt;/div&gt;js：    function getImg(e) {        setDragingStyle(e,{borderColor: &apos;#dcdcdc&apos;});// 取消拖放中样式        var imgArea = document.getElementsByClassName(&apos;up-area&apos;);        // 限制上传数量        if(imgArea[0].childNodes.length &gt;= 9){            alert(&apos;一次最多上传9张图片..&apos;)            return;        }        var f = e.dataTransfer.files[0];      //找到拖放的文件        var fr = new FileReader();        //创建文件读取器        fr.readAsDataURL(f);         //读取文件内容        fr.onload = function () {       //读取完成            var img = new Image();            img.src = fr.result;        //使用读取到的数据            img.style.width = &apos;100px&apos;;            img.style.height = &apos;100px&apos;;            e.target.appendChild(img);        }    }</code></pre><p>效果：<a href="https://wenfujie.github.io/document-library/js-library/H5-drag-drop/拖拽demo-上传图片版.html" target="_blank" rel="noopener"><strong>Demo</strong></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=
      
    
    </summary>
    
      <category term="技术" scheme="http://wenf.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="html5" scheme="http://wenf.top/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>前端初级核心基础</title>
    <link href="http://wenf.top/2019/04/10/%E4%BD%8E%E7%AB%AF%E5%8E%9F%E7%90%86/"/>
    <id>http://wenf.top/2019/04/10/低端原理/</id>
    <published>2019-04-10T06:19:42.000Z</published>
    <updated>2021-03-22T01:06:45.482Z</updated>
    
    <content type="html"><![CDATA[<hr><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1345848098&auto=0&height=66"></iframe><hr><h3 id="1-0-双向数据绑定"><a href="#1-0-双向数据绑定" class="headerlink" title="1.0 双向数据绑定"></a>1.0 双向数据绑定</h3><p>Vue 采用 <strong>数据劫持</strong> 结合 <strong>发布者-订阅者</strong> 模式的方式，通过 <code>Object.defineProperty()</code> 来劫持各个属性的 setter 以及 getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><ol><li>第一步：需要 Observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</li><li>第二步：Compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新数据。</li><li>第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情有：<ol><li>在自身实例化时往属性订阅器（dep）里面添加自己。</li><li>自身必须有一个 update() 方法</li><li>待属性变动 <code>dep.notice()</code> 通知时，能调用自身的 <code>update()</code> 方法，并触发 Compile 中绑定的回调，则功成身退。</li></ol></li><li>第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的桥梁，达到数据变化 -&gt; 视图更新；视图交互变化（input） -&gt; 数据 model 变更的双向绑定效果。</li></ol><blockquote><p>js 实现简单的双向绑定</p></blockquote><pre><code>&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt;    &lt;p id=&quot;show&quot;&gt;&lt;/p&gt;  &lt;/div&gt;  &lt;script&gt;    window.onload = function() {      let obj = {};      Object.defineProperty(obj, &quot;txt&quot;, {        get: function() {          return obj;        },        set: function(newValue) {          document.getElementById(&quot;txt&quot;).value = newValue;          document.getElementById(&quot;show&quot;).innerHTML  = newValue;        }      })      document.addEventListener(&quot;keyup&quot;, function(e) {        obj.txt = e.target.value;      })    }  &lt;/script&gt;&lt;/body&gt;</code></pre><blockquote><p>Object.defineProperty 接收三个参数：对象，属性名，配置对象<br>这里使用的是 Object.defineProperty，这是 Vue 2.0 进行双向数据绑定的写法。在 Vue 3.0 中，它使用 Proxy 进行数据劫持。</p></blockquote><ul><li>为什么 Vue 3.0 中使用 Proxy 了？</li></ul><ol><li>Vue 中使用 Object.defineProperty 进行双向数据绑定时，告知使用者是可以监听数组的，但是只是监听了数组的 push()、pop()、shift()、unshift()、splice()、sort()、reverse() 这八种方法，其他数组的属性检测不到。</li><li>Object.defineProperty 只能劫持对象的属性，因此对每个对象的属性进行遍历时，如果属性值也是对象需要深度遍历，那么就比较麻烦了，所以在比较 Proxy 能完整劫持对象的对比下，选择 Proxy。</li><li>为什么 Proxy 在 Vue 2.0 编写的时候出来了，尤大却没有用上去？因为当时 es6 环境不够成熟，兼容性不好，尤其是这个属性无法用 polyfill 来兼容。（polyfill 是一个 js 库，专门用来处理 js 的兼容性问题-js 修补器）</li></ol><blockquote><p>参考自<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F2df6dcddb0d7" target="_blank" rel="noopener">《实现双向绑定Proxy比defineproperty优劣如何》</a></p></blockquote><h3 id="2-0-template-编译"><a href="#2-0-template-编译" class="headerlink" title="2.0 template 编译"></a>2.0 template 编译</h3><ul><li>Vue template 编译的理解</li></ul><p>Vue 中 template 就是先转化成 AST 树，再得到 render 函数返回 VNode（Vue 的虚拟 DOM 节点）。</p><ol><li>通过 compile 编译器把 template 编译成 AST 语法树（abstract syntax tree - 源代码的抽象语法结构的树状表现形式），compile 是 createCompiler 的返回值，createCompiler 是用以创建编译器的。另外 compile 还负责合并 option。</li><li>AST 会经过 generate（将 AST 语法树转换成 render function 字符串的过程）得到 render 函数，render 的返回值是 VNode，VNode 是 Vue 的虚拟 DOM 节点，里面有标签名、子节点、文本等待。</li></ol><h3 id="3-0-基础优化"><a href="#3-0-基础优化" class="headerlink" title="3.0 基础优化"></a>3.0 基础优化</h3><h4 id="3-1-HTML-优化"><a href="#3-1-HTML-优化" class="headerlink" title="3.1 HTML 优化"></a>3.1 HTML 优化</h4><ol><li>避免 HTML 中书写 CSS 代码，因为这样难以维护。</li><li>使用 Viewport 加速页面的渲染。</li><li>使用语义化标签，减少 CSS 代码，增加可读性和 SEO。</li><li>减少标签的使用，DOM 解析是一个大量遍历的过程，减少不必要的标签，能降低遍历的次数。</li><li>避免 src、href 等的值为空，因为即时它们为空，浏览器也会发起 HTTP 请求。</li><li>减少 DNS 查询的次数。</li></ol><h4 id="3-2-CSS-优化"><a href="#3-2-CSS-优化" class="headerlink" title="3.2 CSS 优化"></a>3.2 CSS 优化</h4><ol><li>优化选择器路径：使用 <code>.c {}</code> 而不是 <code>.a .b .c {}</code>。</li><li>选择器合并：共同的属性内容提起出来，压缩空间和资源开销。</li><li>精准样式：使用 <code>padding-left: 10px</code> 而不是 <code>padding: 0 0 0 10px</code>。</li><li>雪碧图：将小的图标合并到一张图中，这样所有的图片只需要请求一次。</li><li>避免通配符：<code>.a .b * {}</code> 这样的选择器，根据从右到左的解析顺序在解析过程中遇到通配符 <code>* {}</code> 会遍历整个 DOM，性能大大损耗。</li><li>少用 float：<code>float</code> 在渲染时计算量比较大，可以使用 flex 布局。</li><li>为 0 值去单位：增加兼容性。</li><li>压缩文件大小，减少资源下载负担。</li></ol><h4 id="3-3-JavaScript-优化"><a href="#3-3-JavaScript-优化" class="headerlink" title="3.3 JavaScript 优化"></a>3.3 JavaScript 优化</h4><ol><li>尽可能把 <code>&lt;script&gt;</code> 标签放在 <code>body</code> 之后，避免 JS 的执行卡住 DOM 的渲染，最大程度保证页面尽快地展示出来。</li><li>尽可能合并 JS 代码：提取公共方法，进行面向对象设计等……</li><li>CSS 能做的事情，尽量不用 JS 来做，毕竟 JS 的解析执行比较粗暴，而 CSS 效率更高。</li><li>尽可能逐条操作 DOM，并预定好 CSs 样式，从而减少 reflow 或者 repaint 的次数。</li><li>尽可能少地创建 DOM，而是在 HTML 和 CSS 中使用 <code>display: none</code> 来隐藏，按需显示。</li><li>压缩文件大小，减少资源下载负担。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=
      
    
    </summary>
    
      <category term="技术" scheme="http://wenf.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Vue" scheme="http://wenf.top/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>小程序基础组件、API、应用场景及生态圈简介</title>
    <link href="http://wenf.top/2018/10/31/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E3%80%81API%E3%80%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E7%AE%80%E4%BB%8B/"/>
    <id>http://wenf.top/2018/10/31/小程序基础组件、API、应用场景及生态圈简介/</id>
    <published>2018-10-31T13:57:42.000Z</published>
    <updated>2021-03-22T01:06:45.483Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小程序的使用场景"><a href="#小程序的使用场景" class="headerlink" title="小程序的使用场景"></a>小程序的使用场景</h3><ol><li>可以取代低频的app，不占空间（如排队、公交车）</li><li>适用功能单一的（因为小程序最大2M）</li><li>适合配合线下店铺一起适用的，扫描即可获取店铺信息</li><li>不适应于高频的app<br> 原因1：和原生app比，入口太深，<br> 原因2：小程序体验虽然比h5要好，但是没有app体验好</li><li>不适用流量和分发的产品（小程序不支持流量）</li></ol><h3 id="小程序SWOT分析"><a href="#小程序SWOT分析" class="headerlink" title="小程序SWOT分析"></a>小程序SWOT分析</h3><ol><li><p>优势Strenths</p><ul><li><p>无需安装、随用随点</p><p>  用户使用成本更低，无需下载安装，通过搜索、扫码、摇一摇、点击分享等形式。在Android系统中，若腾讯将微信小程序图标发布到操作系统桌面中，可令用户几乎分辨不出原生APP与小程序。</p></li><li><p>跨平台开发</p><p>  微信APP已屏蔽了IOS和Android的差异，在相同版本的微信APP下，开发者无需关心操作系统的类型与版本，一套代码可满足各平台需求。</p></li><li><p>丰富的组件和API</p></li></ul></li><li><p>劣势Weaknesses</p><ul><li><p>客户端计算能力不及APP：</p><p>  因微信小程序使用H5技术，代码运行环境为webkit引擎，无法运行复杂的大型计算，某些场景无法支持。</p></li></ul></li><li><p>机会Opportunities</p><ul><li><p>巨大流量入口：</p><p>  微信作为国内装机量最大的APP，月活用户已超过8亿，微信朋友圈用户粘度很高，利于小程序的推广使用。</p></li><li><p>技术较为成熟：</p><p>  小程序所需技能点为html+js+css，相关技术从业人员广、技术成熟，开发上手容易，学习成本低。</p></li><li><p>满足客户新鲜感体验：</p><p>  微信小程序推出不久，网络讨论热度高，部分用户会出于尝鲜心理体验小程序。</p></li></ul></li><li><p>威胁Threats</p><ul><li><p>数据安全性较低：</p><p>  小程序的编写语言为解释执行语言，发布小程序需把源码发布到腾讯服务器，运行环境为微信APP内嵌浏览器，开发者需对腾讯的信任级别达到操作系统级别。</p></li><li><p>自由度受制于微信：</p><p>  接口和权限均依赖于微信及其API，小程序能实现的功能场景，完全依赖于微信APP提供的能力。小程序的开发自由度是没有native app高的。</p></li><li><p>对自家APP造成冲击：</p><p>  因为小程序良好的体验和强大的可扩展性，客户容易分流，对自家APP的装机量和使用时长造成冲击。</p></li></ul></li></ol><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>一个小程序主体部分由三个文件组成，必须放在项目的根目录</p><p><a href="http://pheputc6t.bkt.clouddn.com/%E5%9B%BE%E7%89%871.png" data-fancybox="group" data-caption="app小程序入口结构" class="fancybox"><img src="http://pheputc6t.bkt.clouddn.com/%E5%9B%BE%E7%89%871.png" alt="app小程序入口结构" title="app小程序入口结构"></a></p><p>一个小程序页面由四个文件组成</p><p><a href="http://pheputc6t.bkt.clouddn.com/%E5%9B%BE%E7%89%872.png" data-fancybox="group" data-caption="页面结构" class="fancybox"><img src="http://pheputc6t.bkt.clouddn.com/%E5%9B%BE%E7%89%872.png" alt="页面结构" title="页面结构"></a></p><h3 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h3><p><a href="http://pheputc6t.bkt.clouddn.com/%E5%9B%BE%E7%89%873.png" data-fancybox="group" data-caption="常用组件" class="fancybox"><img src="http://pheputc6t.bkt.clouddn.com/%E5%9B%BE%E7%89%873.png" alt="常用组件" title="常用组件"></a></p><h3 id="文档Api结构"><a href="#文档Api结构" class="headerlink" title="文档Api结构"></a>文档Api结构</h3><p><a href="http://pheputc6t.bkt.clouddn.com/%E5%9B%BE%E7%89%874.png" data-fancybox="group" data-caption="文档Api结构" class="fancybox"><img src="http://pheputc6t.bkt.clouddn.com/%E5%9B%BE%E7%89%874.png" alt="文档Api结构" title="文档Api结构"></a></p><h3 id="小程序高频基础开发组件、API"><a href="#小程序高频基础开发组件、API" class="headerlink" title="小程序高频基础开发组件、API"></a>小程序高频基础开发组件、API</h3><h4 id="view基础容器（更多）"><a href="#view基础容器（更多）" class="headerlink" title="view基础容器（更多）"></a>view基础容器（<a href="https://developers.weixin.qq.com/miniprogram/dev/component/view.html" title="更多" target="_blank" rel="noopener">更多</a>）</h4><pre><code>&lt;view class=&quot;flex-item bc_green&quot; hover-class=”className” hover-start-time=“{{50}}”&gt;1&lt;/view&gt;hover-class 按击时添加className类；hover-start-time 按住后多久出现点击态，单位毫秒</code></pre><h4 id="滚动容器（更多）"><a href="#滚动容器（更多）" class="headerlink" title="滚动容器（更多）"></a>滚动容器（<a href="https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html" target="_blank" rel="noopener">更多</a>）</h4><pre><code>&lt;scroll-view scroll-y style=&quot;height: 200px;&quot; bindscrolltoupper=&quot;upper&quot; bindscrolltolower=&quot;lower&quot; bindscroll=&quot;scroll&quot; scroll-top=&quot;{{scrollTop}}&quot;&gt; &lt;/scroll-view&gt;scroll-y 允许纵向滚动Bindscrolltoupper 滚动到顶部/左边，会触发 scrolltoupper 事件Bindscrolltolower 滚动到底部/右边，会触发 scrolltolower 事件Bindscroll 滚动时触发scroll-top 设置竖向滚动条位置</code></pre><p>注意：使用竖向滚动时，需要给<scroll-view>一个固定高度，通过 WXSS 设置 height</scroll-view></p><h4 id="跳转页面（更多）"><a href="#跳转页面（更多）" class="headerlink" title="跳转页面（更多）"></a>跳转页面（<a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html" target="_blank" rel="noopener">更多</a>）</h4><p>使用navigator标签,与html5的a标签相似</p><pre><code>&lt;navigator url=&quot;/page/navigate/navigate?title=navigate&quot; hover-class=&quot;navigator-hover&quot;&gt;    跳转到新页面&lt;/navigator&gt;url 当前小程序内的跳转链接target 在哪个目标上发生跳转，默认当前小程序，可选值self/miniProgramhover-class 指定点击时的样式类，当hover-class=&quot;none&quot;时，没有点击态效果open-type 跳转方式</code></pre><p>open-type有效值:</p><ol><li>navigate 对应 wx.navigateTo 保留当前页面，跳转到应用内的某个页面</li><li>redirect 对应 wx.redirectTo 关闭当前页面，跳转到应用内的某个页面</li><li>switchTab 对应 wx.switchTab 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面</li><li>reLaunch 对应 wx.reLaunch 关闭所有页面，打开到应用内的某个页面</li><li>navigateBack 对应 wx.navigateBack 关闭当前页面，返回上一页面或多级页面。</li><li>exit 退出小程序，target=”miniProgram”时生效</li></ol><p>js跳转</p><pre><code>//保留当前页面,跳转相应页面wx.navigateTo({url:&apos;/page/navigate/navigate?title=navigate&apos;});//返回上一页wx.navigateBack({delta:1})//关闭当前页，跳转到某个页面wx.redirectTo({ url: &apos;/page/navigate/navigate?title=navigate&apos;})</code></pre><h4 id="图片（更多）"><a href="#图片（更多）" class="headerlink" title="图片（更多）"></a>图片（<a href="https://developers.weixin.qq.com/miniprogram/dev/component/image.html" target="_blank" rel="noopener">更多</a>）</h4><pre><code>&lt;image mode=&quot;scaleToFill&quot; src=&quot;{{src}}&quot; lazy-load=“{{true}} bindload=&quot;imgLoad&quot;&gt;&lt;/image&gt;mode 图片裁剪模式(默认：scaleToFill)lazy-load 图片懒加载。只针对page与scroll-view下的image有效bindload 当图片载入完毕时触发回调binderror 当图片载入错误时触发回调</code></pre><p>mode属性值：</p><p>原图</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/image/cat/0.jpg?t=18102614" data-fancybox="group" data-caption="原图" class="fancybox"><img src="https://developers.weixin.qq.com/miniprogram/dev/image/cat/0.jpg?t=18102614" alt="原图" title="原图"></a></p><p><strong>scaleToFill</strong><br>不保持纵横比缩放图片，使图片完全适应</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/image/cat/1.png?t=18102614" data-fancybox="group" data-caption="原图" class="fancybox"><img src="https://developers.weixin.qq.com/miniprogram/dev/image/cat/1.png?t=18102614" alt="原图" title="原图"></a></p><p><strong>aspectFit</strong><br>保持纵横比缩放图片，使图片的长边能完全显示出来</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/image/cat/2.png?t=18102614" data-fancybox="group" data-caption="原图" class="fancybox"><img src="https://developers.weixin.qq.com/miniprogram/dev/image/cat/2.png?t=18102614" alt="原图" title="原图"></a></p><p><strong>aspectFill</strong><br>保持纵横比缩放图片，只保证图片的短边能完全显示出来</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/image/cat/3.png?t=18102614" data-fancybox="group" data-caption="原图" class="fancybox"><img src="https://developers.weixin.qq.com/miniprogram/dev/image/cat/3.png?t=18102614" alt="原图" title="原图"></a></p><p>注意：image组件默认宽度300px、高度225px。image组件中二维码/小程序码图片不支持长按识别。仅在wx.previewImage中支持长按识别。</p><h4 id="全局配置（更多）"><a href="#全局配置（更多）" class="headerlink" title="全局配置（更多）"></a>全局配置（<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">更多</a>）</h4><p>小程序配置文件app,json可配置项很多，说一下常用的window和tabBar的配置</p><p>Window</p><p>设置小程序的状态栏、导航条、标题、窗口背景色。</p><pre><code>{  &quot;window&quot;:{    &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;,    &quot;navigationBarTextStyle&quot;: &quot;black&quot;,    &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;,    &quot;backgroundColor&quot;: &quot;#eeeeee&quot;,    &quot;backgroundTextStyle&quot;: &quot;light&quot;  }}</code></pre><p><a href="https://developers.weixin.qq.com/miniprogram/dev/image/config.jpg?t=18103009" data-fancybox="group" data-caption class="fancybox"><img src="https://developers.weixin.qq.com/miniprogram/dev/image/config.jpg?t=18103009" alt title></a></p><p>tabBar</p><p>底部可切换tab栏设置</p><pre><code>&quot;tabBar&quot;: {  &quot;color&quot;:&quot;#000&quot;,  &quot;selectedColor&quot;:&quot;red&quot;,  &quot;backgroundColor&quot;:&quot;#fff&quot;,  &quot;borderStyle&quot;:&quot;#dcdcdc&quot;,  &quot;position&quot;:&quot;bottom&quot;,  &quot;list&quot;: [{    &quot;pagePath&quot;: &quot;pages/index/index&quot;,    &quot;text&quot;: &quot;商品&quot;,    &quot;iconPath&quot;: &quot;img/goods.png&quot;,    &quot;selectedIconPath&quot;: &quot;img/goods_active.png&quot;  },  {    &quot;pagePath&quot;: &quot;pages/order/order&quot;,    &quot;text&quot;: &quot;订单&quot;,    &quot;iconPath&quot;: &quot;img/order.png&quot;,    &quot;selectedIconPath&quot;: &quot;img/order_active.png&quot;  }]}</code></pre><p><a href="https://developers.weixin.qq.com/miniprogram/dev/image/tabbar.png?t=18103009" data-fancybox="group" data-caption class="fancybox"><img src="https://developers.weixin.qq.com/miniprogram/dev/image/tabbar.png?t=18103009" alt title></a></p><p>tabBar下可配置属性：</p><ul><li>color tab上的文字默认颜色</li><li>selectedColor tab上的文字选中时的颜色</li><li>backgroundColor tab的背景色</li><li>borderStyle tabbar上边框的颜色， 仅支持 black / white</li><li>position tabBar的位置，仅支持 bottom / top</li><li><p>list tab的列表，详见 list 属性说明，最少2个、最多5个 tab</p><p>  list属性的值</p><ol><li>pagePath 页面路径，必须在 pages 中先定义</li><li>text tab 上按钮文字</li><li>iconPath 图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，不支持网络图片。</li><li>selectedIconPath 选中时的图片路径</li></ol></li></ul><h4 id="生命周期（更多）"><a href="#生命周期（更多）" class="headerlink" title="生命周期（更多）"></a>生命周期（<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" target="_blank" rel="noopener">更多</a>）</h4><ol><li><p>onLoad(query)</p><p> 页面加载时触发。一个页面只会调用一次，query（打开当前页面路径中的参数）</p></li><li><p>onReady</p><p> 页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。<br>注意：对界面内容进行设置的 API 如wx.setNavigationBarTitle，请在onReady之后进行。</p></li><li><p>onShow</p><p> 页面显示/切入前台时触发。</p></li><li><p>onHide</p><p> 页面隐藏/切入后台时触发。 如 navigateTo 或底部 tab 切换到其他页面，小程序切入后台等。</p></li><li><p>onUnload</p><p> 页面卸载时触发。如redirectTo或navigateBack到其他页面时。</p></li></ol><h4 id="数据请求"><a href="#数据请求" class="headerlink" title="数据请求"></a>数据请求</h4><pre><code>wx.request({  url: &apos;https://www.apiopen.top/femaleNameApi?page=1&apos;,   data: {    x: &apos;&apos;,    y: &apos;&apos;  },  header: {    &apos;content-type&apos;: &apos;application/json&apos; // 默认值  },  success (res) {    console.log(res.data)  }})</code></pre><p>为保证数据的安全性，小程序中强制要求使用https,且所访问的https地址必须在小程序后台账号中被加入到可信域名中。否则请求失败。</p><p><a href="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=1151228019,460177609&amp;fm=173&amp;s=182A5C3287FA442308EC74DC000080B1&amp;w=640&amp;h=316&amp;img.JPEG" data-fancybox="group" data-caption class="fancybox"><img src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=1151228019,460177609&amp;fm=173&amp;s=182A5C3287FA442308EC74DC000080B1&amp;w=640&amp;h=316&amp;img.JPEG" alt title></a></p><p>该配置项位于小程序账号的“设置”→“开发设置”→“服务器域名”选项中。</p><h4 id="setData函数（更多）"><a href="#setData函数（更多）" class="headerlink" title="setData函数（更多）"></a>setData函数（<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html#pageprototypesetdataobject-data-function-callback" target="_blank" rel="noopener">更多</a>）</h4><p>Page.prototype.setData(Object data, Function callback)</p><p>setData 函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步）。</p><pre><code>// 修改数据可以是数组对应下标的某个属性或对象的单个属性。this.setData({  &apos;array[0].text&apos;:&apos;changed data&apos;},function(){    Console.log(“渲染完成后打印”)})</code></pre><p>属性：</p><ol><li>data Object 这次要改变的数据</li><li>callback Function setData引起的界面更新渲染完毕后的回调函数</li></ol><p>注意：</p><ol><li>直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致。</li><li>仅支持设置可 JSON 化的数据。</li><li>单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。</li><li>请不要把 data 中任何一项的 value 设为 undefined ，否则这一项将不被设置并可能遗留一些潜在问题。</li></ol><h4 id="事件-更多"><a href="#事件-更多" class="headerlink" title="事件(更多)"></a>事件(<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html" target="_blank" rel="noopener">更多</a>)</h4><pre><code>// 点击事件bindtap&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat&quot; bindtap=&quot;tapName&quot;&gt; Click me! &lt;/view&gt;Page({  tapName: function(event) {    // 可以从event中获取到data-hi的值    console.log(event)  }})</code></pre><p>事件绑定方式有两种，分别以以bind或catch开头，bind和catch后可以紧跟一个冒号，其含义不变。</p><pre><code>bindtap=&quot;functionName&quot; 或 bind:tap=&quot;functionName&quot;catchtouchstart=&quot;functionName&quot; 或 catch:touchstart=&quot;functionName&quot;</code></pre><p>bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。</p><p>需要在捕获阶段监听事件时，可以采用capture-bind、capture-catch关键字，后者将中断捕获阶段和取消冒泡阶段。</p><h4 id="自定义组件（更多）"><a href="#自定义组件（更多）" class="headerlink" title="自定义组件（更多）"></a>自定义组件（<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/" target="_blank" rel="noopener">更多</a>）</h4><ol><li><p>创建自定义组件</p><p> 类似于页面，一个自定义组件由 json wxml wxss js 4个文件组成。要编写一个自定义组件，首先需要在 json 文件中进行自定义组件声明（将 component 字段设为 true 可这一组文件设为自定义组件）：</p><pre><code>{    &quot;component&quot;: true}</code></pre><p> 在 wxml 和 wxss 添加模板和样式，其中在 js 中需要使用 Component() 来注册组件，并提供组件的属性定义、内部数据和自定义方法。</p><p> Component构造器（<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/component.html" target="_blank" rel="noopener">更多</a>）代码示例</p><pre><code>Component({  properties: {    // 这里定义了innerText属性，属性值可以在组件使用时指定    innerText: {      type: String,      value: &apos;default value&apos;,    }  },  data: {    // 这里是一些组件内部数据    someData: {}  },  methods: {    // 这里是一个自定义方法    customMethod: function(){}  }})</code></pre></li><li><p>引用自定义组件</p><p> 先要在页面的 json 文件中进行引用声明。</p><pre><code>{  &quot;usingComponents&quot;: {    &quot;component-tag-name&quot;: &quot;path/to/the/custom/component&quot;  }}</code></pre><p> 在wxml模板中使用</p><pre><code>&lt;view&gt;  &lt;!-- 以下是对一个自定义组件的引用 --&gt;  &lt;component-tag-name inner-text=&quot;Some text&quot;&gt;&lt;/component-tag-name&gt;&lt;/view&gt;</code></pre></li><li><p>组件间通信</p><ul><li><p>WXML 数据绑定：用于父组件向子组件的指定属性设置数据</p><pre><code>&lt;component-tag-name inner-text=&quot;Some text&quot;&gt;&lt;/component-tag-name&gt;</code></pre></li><li><p>事件：用于子组件向父组件传递数据，可以传递任意数据。</p><pre><code>&lt;!-- 当自定义组件触发“myevent”事件时，调用“onMyEvent”方法 --&gt;&lt;component-tag-name bindmyevent=&quot;onMyEvent&quot; /&gt;// 使用 triggerEvent 方法触发事件myeventthis.triggerEvent(&apos;myevent&apos;, myEventDetail, myEventOption)</code></pre></li><li>如果以上两种方式不足以满足需要，父组件还可以通过 this.selectComponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。</li></ul></li><li><p>behaviors 组件的混合属性（<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html" target="_blank" rel="noopener">更多</a>）</p><p> 类似于vue的 “mixins” </p><p> 每个 behavior 可以包含一组属性、数据、生命周期函数和方法，组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用。每个组件可以引用多个 behavior 。 behavior 也可以引用其他 behavior 。</p><ul><li><p>定义 behaviors 使用 Behavior() 构造器定义。</p><pre><code>// my-behavior.jsmodule.exports = Behavior({  behaviors: [],  properties: {    myBehaviorProperty: {      type: String    }  },  data: {    myBehaviorData: {}  },  attached: function(){},  methods: {    myBehaviorMethod: function(){}  }}) </code></pre></li><li><p>引入 behaviors </p><pre><code>// my-component.jsvar myBehavior = require(&apos;my-behavior&apos;)Component({  behaviors: [myBehavior],  properties: {    myProperty: {      type: String    }  }})</code></pre></li><li><p>字段的覆盖和组合规则</p><p>组件和它引用的 behavior 中可以包含同名的字段，对这些字段的处理方法如下：</p><ul><li>如果有同名的属性或方法，组件本身的属性或方法会覆盖 behavior 中的属性或方法，如果引用了多个 behavior ，在定义段中靠后 behavior 中的属性或方法会覆盖靠前的属性或方法；</li><li>如果有同名的数据字段，如果数据是对象类型，会进行对象合并，如果是非对象类型则会进行相互覆盖；</li><li>生命周期函数不会相互覆盖，而是在对应触发时机被逐个调用。如果同一个 behavior 被一个组件多次引用，它定义的生命周期函数只会被执行一次。</li></ul></li></ul></li></ol><h4 id="插件的使用"><a href="#插件的使用" class="headerlink" title="插件的使用"></a>插件的使用</h4><p>小程序开发者可便捷地把插件添加到自己的小程序内，丰富小程序的服务。</p><p>接入流程</p><ol><li><p>在小程序管理后台添加插件</p><p> 小程序开发者可在”小程序管理后台-设置-第三方服务-插件管理“中，根据AppID查找需要的插件，并申请使用。</p></li><li><p>在小程序代码中使用插件</p><p> 对于插件的使用者，使用插件前要在 app.json 中声明需要使用的插件，例如：</p></li></ol><pre><code>    {      &quot;plugins&quot;: {        &quot;myPlugin&quot;: {              &quot;version&quot;: &quot;1.0.0&quot;,              &quot;provider&quot;: &quot;wxxxxxxxxxxxxxxxxx&quot;        }      }    }如上例所示， plugins 定义段中可以包含多个插件声明，每个插件声明中都必须指明插件的 appid 和需要使用的版本号。</code></pre><ol><li><p>使用插件的 js 接口<br>在引入插件代码包之后，就可以在这个小程序中使用插件提供的自定义组件或者 js 接口。</p><p> 如果需要使用插件的 js 接口，可以使用 requirePlugin 方法：</p><pre><code>var myPluginInterface = requirePlugin(&apos;myPlugin&apos;)myPluginInterface.hello()</code></pre></li><li><p>使用插件的自定义组件</p><p> 使用插件提供的自定义组件，和使用普通自定义组件的方式相仿。在 json 文件定义需要引入的自定义组件时，使用 plugin:// 协议即可，例如：</p><pre><code>{  &quot;usingComponents&quot;: {    &quot;hello-component&quot;: &quot;plugin://myPlugin/hello-component&quot;  }}</code></pre><p> 注意，出于对插件的保护，插件提供的自定义组件在使用上有一定的限制：</p><ul><li>页面中的 this.selectComponent 接口无法获得插件的自定义组件实例对象；</li><li>wx.createSelectorQuery 等接口的 &gt;&gt;&gt; 选择器无法选入插件内部。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小程序的使用场景&quot;&gt;&lt;a href=&quot;#小程序的使用场景&quot; class=&quot;headerlink&quot; title=&quot;小程序的使用场景&quot;&gt;&lt;/a&gt;小程序的使用场景&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;可以取代低频的app，不占空间（如排队、公交车）&lt;/li&gt;
&lt;li&gt;适用功能单一
      
    
    </summary>
    
      <category term="技术" scheme="http://wenf.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="小程序" scheme="http://wenf.top/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>良好js代码风格的养成</title>
    <link href="http://wenf.top/2018/06/13/%E8%89%AF%E5%A5%BDjs%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%85%BB%E6%88%90/"/>
    <id>http://wenf.top/2018/06/13/良好js代码风格的养成/</id>
    <published>2018-06-13T12:25:25.000Z</published>
    <updated>2021-03-22T01:06:45.483Z</updated>
    
    <content type="html"><![CDATA[<p>软件生命周期中80%的成本都消耗在了维护上；而且几乎所有的维护者都不是代码的直接开发人。<br>如何让自己写的代码让别人阅读起来更高效？当然是写代码的时候注入一些规范。<br>那么在Javascript中有哪些编程风格值得我们去注重呢？这篇文章将总结《编写可维护的JavaScript》里面的观点。</p><h2 id="缩进风格"><a href="#缩进风格" class="headerlink" title="缩进风格"></a>缩进风格</h2><p>上图是Stack Overflow的调查，可见，大部分的Programmer都喜欢用tab进行缩进。每行缩进由4个空格组成。</p><h2 id="语句结尾"><a href="#语句结尾" class="headerlink" title="语句结尾"></a>语句结尾</h2><p>建议不要省略分号。很多人喜欢写js代码很依赖于自动分号插入，也就是语句后面不加分号。<br>但是这是大多数的情况，像return这样的语句是会出错的。类似的还有其他一些语法，这里就不细说自动分号插入机制了，<br>感兴趣的童鞋可以前往<a href="https://cnodejs.org/topic/56dbbd25820d3c9b3d63e369" target="_blank" rel="noopener">JavaScript ASI 机制详解</a>。</p><h2 id="行的长度"><a href="#行的长度" class="headerlink" title="行的长度"></a>行的长度</h2><p>这个之前在另外一篇博客中有介绍过，为了保证在小屏笔记本和大屏幕上看到的代码是一致的，<br>通常建议每一行代码不要超过80列。</p><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>代码长度超过80列，换行也是有讲究的。建议换行的代码增加两个缩进长度。例如：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">callFunction(element1, element2, element3, element4,</span><br><span class="line">        element5);</span><br></pre></td></tr></table></figure></div></p><h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>整个函数代码没有空行地紧凑在一起会给阅读代码的人一定的视觉疲劳。也让人厌倦，起码我看到这样的代码就不想再看下去了。对于空行地建议：</p><ul><li>在方法之间</li><li>在方法中的局部变量和第一条语句之间</li><li>在注释之前</li><li>在方法内的逻辑片段之间插入空行，提高可读性</li></ul><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>命名是我觉得规范中最难的点，怎么让变量或者函数名称还有意境。结合不同的场景，设置不一样的名称。<br>让维护代码的人像看小说一般地阅读代码，就说明命名是成功的！除了变量含义之外，其他的一些规范比如：</p><ul><li>驼峰写法</li><li>变量用名词</li><li>函数用动词+名词</li><li>对象私有属性或方法前面加_</li><li>常量用全部大写字母且分割单词用下划线</li><li>构造函数首字母大写，且以非动词开头</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><ul><li>独占一行，用来解释下一行代码<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    // 如果代码执行到这里，代表通过了condition的校验</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ul><p>注意注释之前要加空行、注释也要缩进。</p><ul><li>与代码同一行，用来解释之前的代码<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result = something + somethingElse;    // somethingElse will never be null</span><br></pre></td></tr></table></figure></div></li></ul><p>注意注释与代码直接至少添加一个缩进。</p><ul><li>多行，用来注释掉一个代码块<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">//     doSomething();</span><br><span class="line">//     doSomethingElse();</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure></div></li></ul><p>注释一个代码块时是在连续多行使用单行注释唯一可以接受的情况。但是最好别这样使用。</p><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 如果代码执行到这里</span><br><span class="line">     * 说明balabala</span><br><span class="line">     */</span><br><span class="line">     doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>要注意缩进、换行、空格、空行。</p><h3 id="使用注释声明"><a href="#使用注释声明" class="headerlink" title="使用注释声明"></a>使用注释声明</h3><p>注释说明，主要用来做记号。主要有以下几种：</p><ol><li><p>TODO说明代码还未完成，说明接下来要做的事情。</p></li><li><p>HACK表明代码实现走了一个捷径。应当包含为何使用hack的原因。同时也表明也许会有更好的解决办法。</p></li><li><p>FIXME说明代码存在bug，应当尽快修复。</p></li><li><p>REVIEW说明代码任何可能的改动都需要评审。</p></li></ol><h2 id="变量、函数和运算符"><a href="#变量、函数和运算符" class="headerlink" title="变量、函数和运算符"></a>变量、函数和运算符</h2><ul><li>变量声明 变量声明习惯一般有两种：一种是“就近”原则，放在离使用最近的地方；第二种就是放在最上面，<br>作为函数内的第一条语句。个人推荐后者，这跟JavaScript引擎解析代码的习惯是一致的。</li></ul><ul><li>函数声明 函数声明也会被JS引擎提前，建议在函数调用之前声明函数。另外，推荐函数内部的局部函数应当紧接着变量声明之后声明。</li></ul><ul><li>立即调用的函数 立即执行函数，在开发中肯定会经常使用。好的写法是：</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var value = (<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        message: <span class="string">'Hi'</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></div><p>清晰明了地的让人知道这是一个立即执行函数。</p><ul><li>严格模式 ES5引入了严格模式，通过这种方式解析执行js代码，来达到减少错误的目的。<br>代码要以strict mode去解析也很简单，只要将use strict放到js代码中即可。<br>当js解析器看到这样一条没有赋给变量的字符串之后，就会以严格模式去解析代码。<br>一个原则：尽量少地影响到更多代码！什么意思呢？use strict可以放到任何位置，全局或者函数局部都可以。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line"><span class="string">"use strict"</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">doSomething</span></span>() &#123;</span><br><span class="line">    // 代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">doSomething</span></span>() &#123;</span><br><span class="line">    <span class="string">"use strict"</span>;</span><br><span class="line">    // 代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如果有多个函数要使用严格模式，就用立即函数限制起来，避免影响到全局。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="string">"use strict"</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">doSomething</span></span>() &#123;</span><br><span class="line">        // 代码</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">doSomethingElse</span></span>() &#123;</span><br><span class="line">        // 代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></div></p><ul><li>相等 使用===、!==代替==、!=，避免类型转换。类型转换的相关内容这里就不说了，自行了解。</li></ul><h2 id="UI层的松耦合"><a href="#UI层的松耦合" class="headerlink" title="UI层的松耦合"></a>UI层的松耦合</h2><p>松耦合的原则：修改一个组件时尽可能不需要修改其他组件代码。</p><ul><li><p>将JavaScript从CSS中抽离 避免使用CSS表达式</p></li><li><p>将CSS从JavaScript中抽离 避免直接修改dom的样式，通过类名去实现想要的效果。</p></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">element.style.cssText = <span class="string">"color: red; left: 10px"</span>;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">.reveal &#123;</span><br><span class="line">    color: red;</span><br><span class="line">    left: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">element.className += <span class="string">" reveal"</span>;</span><br></pre></td></tr></table></figure></div><ul><li>将JavaScript从HTML中抽离 避免直接在HTML写事件处理程序和逻辑代码</li></ul><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>两个规则：</p><ul><li>隔离程序逻辑 将应用逻辑从所有事件处理程序中抽离出来是最佳实践，举个例子：</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line"><span class="keyword">function</span> handleClick(event) &#123;</span><br><span class="line">    var popup = document.getElementById(<span class="string">"popup"</span>);</span><br><span class="line">    popup.style.left = event.clientX + <span class="string">"px"</span>;</span><br><span class="line">    popup.style.top = event.clientY + <span class="string">"px"</span>;</span><br><span class="line">    popup.className = <span class="string">"reveal"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line"><span class="keyword">function</span> handleClick(event) &#123;</span><br><span class="line">    showPopup(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> showPopup(event) &#123;</span><br><span class="line">    popup.style.left = event.clientX + <span class="string">"px"</span>;</span><br><span class="line">    popup.style.top = event.clientY + <span class="string">"px"</span>;</span><br><span class="line">    popup.className = <span class="string">"reveal"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>不要滥用事件对象 将事件对象event一直传递下去是个很烂的实践。<br>别人并不知道你具体使用到事件对象的什么属性或者方法。继续用上面的例子：</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line"><span class="keyword">function</span> handleClick(event) &#123;</span><br><span class="line">    showPopup(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> showPopup(event) &#123;</span><br><span class="line">    popup.style.left = event.clientX + <span class="string">"px"</span>;</span><br><span class="line">    popup.style.top = event.clientY + <span class="string">"px"</span>;</span><br><span class="line">    popup.className = <span class="string">"reveal"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line"><span class="keyword">function</span> handleClick(event) &#123;</span><br><span class="line">    showPopup(event.clientX, event.clientY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> showPopup(x, y) &#123;</span><br><span class="line">    popup.style.left = x + <span class="string">"px"</span>;</span><br><span class="line">    popup.style.top = y + <span class="string">"px"</span>;</span><br><span class="line">    popup.className = <span class="string">"reveal"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="结束"><a href="#结束" class="headerlink" title="结束~"></a>结束~</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;软件生命周期中80%的成本都消耗在了维护上；而且几乎所有的维护者都不是代码的直接开发人。&lt;br&gt;如何让自己写的代码让别人阅读起来更高效？当然是写代码的时候注入一些规范。&lt;br&gt;那么在Javascript中有哪些编程风格值得我们去注重呢？这篇文章将总结《编写可维护的JavaS
      
    
    </summary>
    
      <category term="技术" scheme="http://wenf.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="js" scheme="http://wenf.top/tags/js/"/>
    
  </entry>
  
</feed>
